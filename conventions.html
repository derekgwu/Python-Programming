<!doctype html>
<html >
<head>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/template.css" />

    <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->

    <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


    <!-- <script src="script.js"></script> -->

    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />
    <link href="./elegant_bootstrap.css" rel="stylesheet" type="text/css" />
    <!-- <link href="https://cdn.rawgit.com/ryangrose/easy-pandoc-templates/948e28e5/css/elegant_bootstrap.css" rel="stylesheet" type="text/css" /> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/script.js"></script>

    <script src="https://cdn.rawgit.com/diversen/pandoc-bootstrap-adaptive-template/959c3622/jquery.sticky-kit.js"></script>
    <meta name="generator" content="pandoc" />
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: rgb(0, 0, 0); text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #f31818;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #006590; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */


/*The header*/
  </style>
</head>
<body>
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">Python Programming</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">Derek Chen</p></li>
                            </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

            
        <ul>
        <li><a href="#python_intro"
        id="toc-intro-to-systems-programming"><span
        class="toc-section-number"></span> Intro to Python</a>
        <ul>
        <li><a href="#python_installation"
        id="toc-computer-organization"><span
        class="toc-section-number"></span> Python Installation</a></li>
        <li><a href="#writing_our_first_program"
        id="toc-memory-hierarchies"><span
        class="toc-section-number"></span> Writing Our First Program</a></li>


        
        <li><a href="#intro-to-c" id="toc-intro-to-c"><span
        class="toc-section-number">1.3</span> Intro to C</a>
        <ul>
        <li><a href="#you-already-know-c"
        id="toc-you-already-know-c">You already know
        <strong>C</strong></a></li>
        <li><a
        href="#c-constructs-if-youre-familiar-with-java-python-etc."
        id="toc-c-constructs-if-youre-familiar-with-java-python-etc."><span
        class="toc-section-number">1.3.1</span> C constructs [if you’re
        familiar with Java, Python, etc.]</a></li>
        <li><a href="#whats-different-from-java"
        id="toc-whats-different-from-java">What’s different [from
        java]</a></li>
        <li><a href="#compound-types" id="toc-compound-types"><span
        class="toc-section-number">1.3.2</span> Compound types</a></li>
        </ul></li>
        </ul></li>
        <li><a href="#intermediate-c" id="toc-intermediate-c"><span
        class="toc-section-number">2</span> Intermediate C</a>
        <ul>
        <li><a href="#objectives" id="toc-objectives"><span
        class="toc-section-number">2.1</span> Objectives</a></li>
        <li><a href="#types" id="toc-types"><span
        class="toc-section-number">2.2</span> Types</a>
        <ul>
        <li><a href="#basic-types" id="toc-basic-types"><span
        class="toc-section-number">2.2.1</span> Basic types</a></li>
        <li><a href="#common-posix-types-and-values"
        id="toc-common-posix-types-and-values"><span
        class="toc-section-number">2.2.2</span> Common POSIX types and
        values</a></li>
        <li><a href="#format-strings" id="toc-format-strings"><span
        class="toc-section-number">2.2.3</span> Format Strings</a></li>
        <li><a href="#compound-types-1" id="toc-compound-types-1"><span
        class="toc-section-number">2.2.4</span> Compound types</a></li>
        <li><a href="#pointers-arrays" id="toc-pointers-arrays"><span
        class="toc-section-number">2.2.5</span> Pointers &amp;
        Arrays</a></li>
        </ul></li>
        <li><a href="#memory-allocation"
        id="toc-memory-allocation"><span
        class="toc-section-number">2.3</span> Memory Allocation</a>
        <ul>
        <li><a href="#common-errors" id="toc-common-errors"><span
        class="toc-section-number">2.3.1</span> Common Errors</a></li>
        </ul></li>
        <li><a href="#exercises" id="toc-exercises"><span
        class="toc-section-number">2.4</span> Exercises</a>
        <ul>
        <li><a href="#c-is-a-thin-language-layer-on-top-of-memory"
        id="toc-c-is-a-thin-language-layer-on-top-of-memory"><span
        class="toc-section-number">2.4.1</span> C is a Thin Language
        Layer on Top of Memory</a></li>
        <li><a href="#quick-and-dirty-key-value-store"
        id="toc-quick-and-dirty-key-value-store"><span
        class="toc-section-number">2.4.2</span> Quick-and-dirty
        Key-Value Store</a></li>
        </ul></li>
        <li><a href="#pointers-and-arrays"
        id="toc-pointers-and-arrays"><span
        class="toc-section-number">2.5</span> Pointers and
        Arrays</a></li>
        <li><a href="#pointer-arithmetic"
        id="toc-pointer-arithmetic"><span
        class="toc-section-number">2.6</span> Pointer
        Arithmetic</a></li>
        <li><a href="#pointer-casting" id="toc-pointer-casting"><span
        class="toc-section-number">2.7</span> Pointer Casting!</a>
        <ul>
        <li><a href="#casting-from-int-to-char"
        id="toc-casting-from-int-to-char"><span
        class="toc-section-number">2.7.1</span> Casting from
        <code>int*</code> to <code>char*</code></a></li>
        <li><a href="#example-3" id="toc-example-3"><span
        class="toc-section-number">2.7.2</span> Example</a></li>
        </ul></li>
        <li><a href="#pointer-casting-void"
        id="toc-pointer-casting-void"><span
        class="toc-section-number">2.8</span> Pointer Casting |
        <code>void*</code></a></li>
        </ul></li>
        <li><a href="#function-pointers"
        id="toc-function-pointers"><span
        class="toc-section-number">3</span> Function Pointers</a>
        <ul>
        <li><a href="#example-bubble-sort"
        id="toc-example-bubble-sort"><span
        class="toc-section-number">3.0.1</span> Example | Bubble
        Sort</a></li>
        <li><a href="#example-generic-bubble-sort"
        id="toc-example-generic-bubble-sort"><span
        class="toc-section-number">3.0.2</span> Example | Generic Bubble
        Sort</a></li>
        <li><a href="#what-is-generic" id="toc-what-is-generic"><span
        class="toc-section-number">3.0.3</span> What is
        “<em>generic</em>”?</a></li>
        <li><a href="#generic-to-concrete-functions"
        id="toc-generic-to-concrete-functions"><span
        class="toc-section-number">3.0.4</span> Generic to
        <em>concrete</em> functions</a></li>
        <li><a href="#putting-it-all-together-using-function-pointers"
        id="toc-putting-it-all-together-using-function-pointers"><span
        class="toc-section-number">3.0.5</span> Putting it all Together
        | Using Function Pointers</a></li>
        <li><a href="#why-bother-if-we-need-concrete-functions-anyways"
        id="toc-why-bother-if-we-need-concrete-functions-anyways"><span
        class="toc-section-number">3.0.6</span> Why bother if we need
        <code>concrete</code> functions anyways?</a></li>
        <li><a
        href="#in-class-exercise-generic-insertion-sort-for-struct"
        id="toc-in-class-exercise-generic-insertion-sort-for-struct"><span
        class="toc-section-number">3.0.7</span> In-class Exercise |
        Generic Insertion Sort for <code>struct</code></a></li>
        </ul></li>
        <li><a href="#c-memory-model-data-structures-and-apis"
        id="toc-c-memory-model-data-structures-and-apis"><span
        class="toc-section-number">4</span> C Memory Model,
        Data-structures, and APIs</a>
        <ul>
        <li><a href="#memory-allocation-options"
        id="toc-memory-allocation-options"><span
        class="toc-section-number">4.1</span> Memory Allocation
        Options</a>
        <ul>
        <li><a href="#internal-allocation"
        id="toc-internal-allocation"><span
        class="toc-section-number">4.1.1</span> Internal
        Allocation</a></li>
        <li><a href="#heap-allocation" id="toc-heap-allocation"><span
        class="toc-section-number">4.1.2</span> Heap Allocation</a></li>
        <li><a href="#global-allocation"
        id="toc-global-allocation"><span
        class="toc-section-number">4.1.3</span> Global
        Allocation</a></li>
        <li><a href="#stack-allocation" id="toc-stack-allocation"><span
        class="toc-section-number">4.1.4</span> Stack
        Allocation</a></li>
        <li><a href="#putting-it-all-together"
        id="toc-putting-it-all-together"><span
        class="toc-section-number">4.1.5</span> Putting it all
        Together</a></li>
        <li><a href="#comparing-c-to-java"
        id="toc-comparing-c-to-java"><span
        class="toc-section-number">4.1.6</span> Comparing C to
        Java</a></li>
        </ul></li>
        <li><a href="#strings" id="toc-strings"><span
        class="toc-section-number">4.2</span> Strings</a>
        <ul>
        <li><a href="#string.h-functions"
        id="toc-string.h-functions"><span
        class="toc-section-number">4.2.1</span> <code>string.h</code>
        Functions</a></li>
        <li><a href="#bonus-explicit-strings"
        id="toc-bonus-explicit-strings"><span
        class="toc-section-number">4.2.2</span> Bonus: Explicit
        Strings</a></li>
        </ul></li>
        <li><a href="#api-design-and-concerns"
        id="toc-api-design-and-concerns"><span
        class="toc-section-number">4.3</span> API Design and
        Concerns</a>
        <ul>
        <li><a href="#return-values" id="toc-return-values"><span
        class="toc-section-number">4.3.1</span> Return Values</a></li>
        <li><a href="#memory-ownership" id="toc-memory-ownership"><span
        class="toc-section-number">4.3.2</span> Memory
        Ownership</a></li>
        </ul></li>
        <li><a href="#exercises-1" id="toc-exercises-1"><span
        class="toc-section-number">4.4</span> Exercises</a>
        <ul>
        <li><a href="#stack-allocation-1"
        id="toc-stack-allocation-1"><span
        class="toc-section-number">4.4.1</span> Stack
        Allocation</a></li>
        <li><a href="#understanding-memory-ownership"
        id="toc-understanding-memory-ownership"><span
        class="toc-section-number">4.4.2</span> Understanding Memory
        Ownership</a></li>
        </ul></li>
        <li><a href="#errors" id="toc-errors"><span
        class="toc-section-number">4.5</span> Errors</a>
        <ul>
        <li><a href="#return-vals-indicate-errors"
        id="toc-return-vals-indicate-errors"><span
        class="toc-section-number">4.5.1</span> <strong>return</strong>
        vals → indicate errors</a></li>
        <li><a href="#errno-variable-and-command"
        id="toc-errno-variable-and-command"><span
        class="toc-section-number">4.5.2</span> <code>errno</code>
        variable and command</a></li>
        <li><a href="#additional-helper-functions"
        id="toc-additional-helper-functions"><span
        class="toc-section-number">4.5.3</span> Additional Helper
        Functions</a></li>
        <li><a
        href="#understand-return-values-of-unix-library-functions"
        id="toc-understand-return-values-of-unix-library-functions"><span
        class="toc-section-number">4.5.4</span> Understand Return Values
        of UNIX library functions:</a></li>
        <li><a
        href="#in-class-exercise-printing-all-error-codesstrings-in-sequence"
        id="toc-in-class-exercise-printing-all-error-codesstrings-in-sequence"><span
        class="toc-section-number">4.5.5</span> In-class Exercise |
        Printing <strong>all</strong> error codes/strings in
        sequence</a></li>
        </ul></li>
        </ul></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <h1 data-number="1" id="python_intro"><span
            class="header-section-number">0</span> Python Introduction</h1>
            <h2 data-number="1.1" id="computer-organization"><span
            class="header-section-number">0.1</span> Introduction</h2>
            <p>Congratulations on deciding to study Python! This HTML document is an interactive guide to learning
            and understanding Python. This document takes a stronger focus on the programming aspects of Python, such
            as the basics and proper coding fundementals. It's a great beginners guide to Python and coding in general.
            In Chapter 0, you'll learn how to install Python and start writing your first programs.
            </a>.</p>
            <h2 data-number="1.2" id="python_installation"><span
            class="header-section-number">0.2</span> Installing Python</h2>
            <p>Firstly,we need to install the proper tools needed to the code. Here's are the tools you'll need to install 
            in order to start coding in Python
            </a>.</p>
            <li>Python itself (duh)</li>
            <li>an IDE (a place to write code)</li>

            <p>To install Python, follow this link <a href=https://www.python.org/downloads/>here.</a></p>

            <p>An IDE is known as an intergrated development environment. It's essentially a place to write code. 
            I recommend installing Visual Studio Code, but there are many other viable IDEs availible.</p>

            <p>To install Visual Studio Code, follow this link <a href="https://code.visualstudio.com/download">here</a></p>

            <p>If you choose to install Visual Studio Code, I also recommend installing the Python extension to help you find syntax mistakes.</p>


            <h2 data-number="1.3" id="writing_our_first_program"><span
            class="header-section-number">0.3</span> Our First Program</h2>
            <p>Once Python and your preferred IDE are installed, it's time to write your first program. We will be writing the <strong>
            Hello World</strong> program.</p>

            <p>Before we start writing anything, we should note where our program will be outputting. Locate
              the terminal on your IDE (you may need to google where it is). This is where your program outputs
              will be displayed (until we learn GUIs).
            </p>

            <p>The purpose of the Hello World program is to display the phrase <strong>Hello World!</strong>
            inside your terminal. You can copy and paste the code below to see it.</p>

            <div class="sourceCode" id="cb1">
                <pre class="sourceCode c">
<code class="sourceCode c">
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span>print<span class="vs">("Hello World")</span></span></span>
</code></pre></div>

            <p>If you compile and run the following program, your terminal should display</p>

            <pre><code>Hello World</code></pre>

            <h3 data-number="1.3.1"
            id="c-constructs-if-youre-familiar-with-java-python-etc."><span
            class="header-section-number">1.3.1</span> C constructs [if
            you’re familiar with Java, Python, etc.]</h3>
            <table>
            <thead>
            <tr class="header">
            <th>construct</th>
            <th>syntax</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td>conditionals</td>
            <td><code>if</code> and <code>else</code></td>
            </tr>
            <tr class="even">
            <td>loops</td>
            <td><code>while{}</code>, <code>do...while</code>,
            <code>for</code></td>
            </tr>
            <tr class="odd">
            <td><strong>basic</strong> types</td>
            <td><code>int</code>, <code>float</code>,
            <code>double</code>, <code>char</code></td>
            </tr>
            <tr class="even">
            <td><strong>compound</strong></td>
            <td><code>arrays</code>*</td>
            </tr>
            <tr class="odd">
            <td>functions</td>
            <td><code>ret_val</code>
            <strong><code>func_name</code></strong>
            <code>(args){}</code></td>
            </tr>
            <tr class="even">
            <td></td>
            <td></td>
            </tr>
            </tbody>
            </table>
            <p>* <strong>no range checks!!</strong>: C will let you
            access an array beyond the maximum size that you have
            specified while creating it. The effects of such access are
            <strong>implementation specific</strong> – each
            platform/operating system will handle it differently. Note
            that on platforms that don’t have memory protection, this
            can cause some serious problems!</p>
            <h3 class="unnumbered" id="whats-different-from-java">What’s
            different [from java]</h3>
            <ul>
            <li>no object-oriented programming</li>
            <li>no function overloading</li>
            <li><strong>no classes!</strong></li>
            <li>we have <code>struct</code> instead
            <ul>
            <li>which is similar but <em>very</em> different</li>
            </ul></li>
            <li><strong>compiled</strong> not interpreted</li>
            <li><strong>pointers!!!</strong></li>
            </ul>
            <h3 data-number="1.3.2" id="compound-types"><span
            class="header-section-number">1.3.2</span> Compound
            types</h3>
            <p><strong>contiguous memory</strong> layouts: objects
            within these data types are laid out in memory, next to each
            other. This becomes important when you’re trying to use
            pointers to access various elements.</p>
            <table>
            <thead>
            <tr class="header">
            <th>type</th>
            <th>usage</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td><scb>struct</scb></td>
            <td>related variables (like class)</td>
            </tr>
            <tr class="even">
            <td><scb>union</scb></td>
            <td>same, but <em>shared</em> memory</td>
            </tr>
            <tr class="odd">
            <td><scb>enum</scb></td>
            <td>enumeration, assign names</td>
            </tr>
            <tr class="even">
            <td>array</td>
            <td>pointer to contiguous memory</td>
            </tr>
            <tr class="odd">
            <td></td>
            <td></td>
            </tr>
            </tbody>
            </table>
            <h4 class="unnumbered" id="no-built-in-boolean"><strong>no
            (built-in) boolean!</strong></h4>
            <p>C does not have a built in boolean data type. We can
            mimic it by using integer values (<scb>0</scb> is
            <code>false</code> while any other non-zero values is
            <code>true</code>).</p>
            <h1 data-number="2" id="intermediate-c"><span
            class="header-section-number">2</span> Intermediate C</h1>
            <h2 data-number="2.1" id="objectives"><span
            class="header-section-number">2.1</span> Objectives</h2>
            <ul>
            <li>Recalling C types with a focus on pointers.</li>
            <li>Focus on more advanced features like
            <code>void *</code>s and function pointers.</li>
            <li>Practice thinking about C programs as memory.</li>
            </ul>
            <h2 data-number="2.2" id="types"><span
            class="header-section-number">2.2</span> Types</h2>
            <h3 data-number="2.2.1" id="basic-types"><span
            class="header-section-number">2.2.1</span> <a
            href="https://en.wikipedia.org/wiki/C_data_types">Basic
            types</a></h3>
            <ul>
            <li><code>char</code> - think “one byte”. Same as
            <code>signed char</code>.</li>
            <li><code>short int</code> - think “two bytes”. Same as
            <code>short</code>.</li>
            <li><code>int</code> - think “four bytes”.</li>
            <li><code>long int</code> - think “potentially larger
            <code>int</code>”. Most commonly known solely as
            <code>long</code>.</li>
            <li><code>float</code>, <code>double</code> - floating point
            values (not used in the class).</li>
            <li><code>void</code> - the lack of a type. Variables
            <em>cannot</em> have this type.</li>
            </ul>
            <div class="sourceCode" id="cb1"><pre
            class="sourceCode c">
            <code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* `void` is fine to denote &quot;no variables/return values&quot;, ... */</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* ...but not fine on variables */</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> a<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>inline_exec_tmp.c:6:7: error: variable has incomplete type &#39;void&#39;
        void a;
             ^
1 error generated.
make[1]: *** [inline_exec_tmp] Error 1</code></pre>
            <ul>
            <li><code>enum</code> - an <code>int</code> or
            <code>short int</code> with some “named” values.</li>
            </ul>
            <div class="sourceCode" id="cb3"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> weekdays <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    MON<span class="op">,</span> TUES<span class="op">,</span> WED<span class="op">,</span> THURS<span class="op">,</span> FRI</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;MON = </span><span class="sc">%d</span><span class="st">, TUES = </span><span class="sc">%d</span><span class="st">, ..., FRI = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> MON<span class="op">,</span> TUES<span class="op">,</span> FRI<span class="op">);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>MON = 0, TUES = 1, ..., FRI = 4</code></pre>
            <p>You can choose the values explicitly
            (e.g. <code>enum grades { MON = 1, TUES = 2, WED = 3, THURS = 4, FRI = 5};</code>).</p>
            <p><strong>Modifiers</strong></p>
            <ul>
            <li><code>unsigned</code> - variables that cannot be
            negative. Given that variables have a fixed bit-width, they
            can use the extra bit (“negative” no longer needs to be
            tracked) to instead represent numbers twice the size of
            <code>signed</code> variants.</li>
            <li><code>signed</code> - signed variables. You don’t see
            this modifier as much because <code>char</code>,
            <code>int</code>, <code>long</code> all default to
            <code>signed</code>.</li>
            <li><code>long</code> - Used to modify another type to make
            it larger in some cases. <code>long int</code> can represent
            larger numbers and is synonymous with <code>long</code>.
            <code>long long int</code> (or <code>long long</code>) is an
            even larger value!</li>
            <li><code>static</code> - this variable should not be
            accessible <em>outside of the .c file</em> in which it is
            defined.</li>
            <li><code>const</code> - an immutable value. We won’t focus
            much on this modifier.</li>
            <li><code>volatile</code> - this variable should be “read
            from memory” every time it is accessed. Confusing now,
            relevant later, but not a focus.</li>
            </ul>
            <h4 data-number="2.2.1.1" id="examples"><span
            class="header-section-number">2.2.1.1</span> Examples</h4>
            <div class="sourceCode" id="cb5"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> a<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">signed</span> <span class="dt">char</span> a_signed<span class="op">;</span>     <span class="co">/* same type as `a` */</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> b<span class="op">;</span>                   <span class="co">/* values between [-128, 127] */</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> b_unsigned<span class="op">;</span> <span class="co">/* values between [0, 256] */</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> <span class="dt">int</span> c_shortint<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> c_short<span class="op">;</span>            <span class="co">/* same as `c_shortint` */</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">int</span> c_longint<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> c_long<span class="op">;</span>              <span class="co">/* same type as `c_longint` */</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>MON = 0, TUES = 1, ..., FRI = 4</code></pre>
            <p>You might see all of these, but the common primitives,
            and their sizes:</p>
            <div class="sourceCode" id="cb7"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Commonly used types that you practically see in a lot of C */</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> uc<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> s<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span> us<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> ui<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> l<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> ul<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;char:</span><span class="sc">\t%ld\n</span><span class="st">short:</span><span class="sc">\t%ld\n</span><span class="st">int:</span><span class="sc">\t%ld\n</span><span class="st">long:</span><span class="sc">\t%ld\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">sizeof</span><span class="op">(</span>c<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span>s<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span>i<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span>l<span class="op">));</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>MON = 0, TUES = 1, ..., FRI = 4</code></pre>
            <h3 data-number="2.2.2"
            id="common-posix-types-and-values"><span
            class="header-section-number">2.2.2</span> Common POSIX
            types and values</h3>
            <ul>
            <li><p><code>stddef.h</code><a href="#fn1"
            class="footnote-ref" id="fnref1"
            role="doc-noteref"><sup>1</sup></a>:</p>
            <ul>
            <li><code>size_t</code>, <code>usize_t</code>,
            <code>ssize_t</code> - types for variables that correspond
            to sizes. These include the size of the memory request to
            <code>malloc</code>, the return value from
            <code>sizeof</code>, and the arguments and return values
            from <code>read</code>/<code>write</code>/…
            <code>ssize_t</code> is signed (allows negative values),
            while the others are unsigned.</li>
            <li><code>NULL</code> - is just
            <code>#define NULL ((void *)0)</code></li>
            </ul></li>
            <li><p><code>limits.h</code><a href="#fn2"
            class="footnote-ref" id="fnref2"
            role="doc-noteref"><sup>2</sup></a>:</p>
            <ul>
            <li><code>INT_MAX</code>, <code>INT_MIN</code>,
            <code>UINT_MAX</code> - maximum and minimum values for a
            signed integer, and the maximum value for an unsigned
            integer.</li>
            <li><code>LONG_MAX</code>, <code>LONG_MIN</code>,
            <code>ULONG_MAX</code> - minimum and maximum numerical
            values for <code>long</code>s and
            <code>unsigned long</code>s.</li>
            <li>Same for <code>short ints</code> (<code>SHRT_MAX</code>,
            etc…) and <code>char</code>s (<code>CHAR_MAX</code>,
            etc…).</li>
            </ul></li>
            </ul>
            <h3 data-number="2.2.3" id="format-strings"><span
            class="header-section-number">2.2.3</span> Format
            Strings</h3>
            <p>Many standard library calls take “format strings”. You’ve
            seen these in <code>printf</code>. The following format
            specifiers should be used:</p>
            <ul>
            <li><code>%d</code> - <code>int</code></li>
            <li><code>%ld</code> - <code>long int</code></li>
            <li><code>%u</code> - <code>unsigned int</code></li>
            <li><code>%c</code> - <code>char</code></li>
            <li><code>%x</code> - <code>unsigned int</code> printed as
            hexadecimal</li>
            <li><code>%lx</code> - <code>long unsigned int</code>
            printed as hexadecimal</li>
            <li><code>%p</code> - prints out any pointer value,
            <code>void *</code></li>
            <li><code>%s</code> - prints out a string,
            <code>char *</code></li>
            </ul>
            <p>Format strings are also used in <code>scanf</code>
            functions to read and parse input.</p>
            <p>You can control the spacing of the printouts using
            <code>%NX</code> where <code>N</code> is the number of
            characters you want printed out (as spaces), and
            <code>X</code> is the format specifier above. For example,
            <code>"%10ld"</code>would print a long integer in a 10
            character slot. Adding <code>\n</code> and <code>\t</code>
            add in the newlines and the tabs. If you need to print out a
            “\”, use <code>\\</code>.</p>
            <h4 data-number="2.2.3.1" id="example"><span
            class="header-section-number">2.2.3.1</span> Example</h4>
            <div class="sourceCode" id="cb9"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Integers: </span><span class="sc">%d</span><span class="st">, </span><span class="sc">%ld</span><span class="st">, </span><span class="sc">%u</span><span class="st">, </span><span class="sc">%c\n</span><span class="st">&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;Hex and pointers: </span><span class="sc">%lx</span><span class="st">, </span><span class="sc">%p\n</span><span class="st">&quot;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;Strings: </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>           INT_MAX<span class="op">,</span> LONG_MAX<span class="op">,</span> UINT_MAX<span class="op">,</span> <span class="ch">&#39;*&#39;</span><span class="op">,</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>           LONG_MAX<span class="op">,</span> <span class="op">&amp;</span>main<span class="op">,</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;hello world&quot;</span><span class="op">);</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x1025ebf00
Strings: hello world</code></pre>
            <h3 data-number="2.2.4" id="compound-types-1"><span
            class="header-section-number">2.2.4</span> Compound
            types</h3>
            <ul>
            <li><code>struct</code> - A collection of different values.
            Example: objects with many different fields.</li>
            <li><code>union</code> - <em>One</em> of a set of values.
            Example: what if you want to represent data for one food
            item among others.</li>
            </ul>
            <p>Unions are not very common, but are sometimes useful. The
            size of a <code>union</code> is the <em>maximum</em> size of
            its fields. In contrast, the <code>struct</code> is the
            <em>sum</em> of the sizes of each of its fields.</p>
            <h4 data-number="2.2.4.1" id="example-1"><span
            class="header-section-number">2.2.4.1</span> Example</h4>
            <div class="sourceCode" id="cb11"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> hamburger <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_burgers<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cheese<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_patties<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> food <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_eggs<span class="op">;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> hamburger burger<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="co">/* Same contents as the union. */</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> all_food <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_eggs<span class="op">;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> hamburger burger<span class="op">;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> food f_eggs<span class="op">,</span> f_burger<span class="op">;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* now I shouldn&#39;t access `.burger` in `f_eggs` */</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    f_eggs<span class="op">.</span>num_eggs <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* This is just syntax for structure initialization. */</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    f_burger<span class="op">.</span>burger <span class="op">=</span> <span class="op">(</span><span class="kw">struct</span> hamburger<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>num_burgers <span class="op">=</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>cheese      <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>num_patties <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* now shouldn&#39;t access `.num_eggs` in `f_burger` */</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Size of union:  </span><span class="sc">%ld\n</span><span class="st">Size of struct: </span><span class="sc">%ld\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>           <span class="kw">sizeof</span><span class="op">(</span><span class="kw">union</span> food<span class="op">),</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> all_food<span class="op">));</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x100f04f00
Strings: hello world</code></pre>
            <p>We can see the effect of the <code>union</code>: The size
            is <code>max(fields)</code> rather than
            <code>sum(fields)</code>. What other examples can you think
            of where you might want <code>union</code>s?</p>
            <blockquote>
            <p>An aside on syntax: The structure initialization syntax
            in this example is simply a shorthand. The
            <code>struct hamburger</code> initialization above is
            equivalent to:</p>
            <div class="sourceCode" id="cb13"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f_burger<span class="op">.</span>burger<span class="op">.</span>num_burgers <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>f_burger<span class="op">.</span>burger<span class="op">.</span>cheese      <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>f_burger<span class="op">.</span>burger<span class="op">.</span>num_patties <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
            <p>Though since there are so many <code>.</code>s, this is a
            little confusing. We’d typically want to simply as:</p>
            <div class="sourceCode" id="cb14"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> hamburger <span class="op">*</span>h <span class="op">=</span> <span class="op">&amp;</span>f_burger<span class="op">.</span>burger<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>h<span class="op">-&gt;</span>num_burgers <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>h<span class="op">-&gt;</span>cheese      <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>h<span class="op">-&gt;</span>num_patties <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
            <p>More on <code>-&gt;</code> in the next section.</p>
            </blockquote>
            <h3 data-number="2.2.5" id="pointers-arrays"><span
            class="header-section-number">2.2.5</span> Pointers &amp;
            Arrays</h3>
            <p>Variables can have be pointer types
            (e.g. <code>int *a</code>). Variables with pointer types are
            pointers and hold an <em>address</em> to the a variable of
            the type to which they point, or to <code>NULL</code>.
            <code>NULL</code> denotes that the pointer is not valid. You
            want to imagine that variables hold data, for example
            <code>int a = 6</code>:</p>
            <pre><code>a---+
| 6 |
+---+</code></pre>
            <p>A pointer, <code>int *b = &amp;a</code> should be
            imagined as a pointer:</p>
            <pre><code>b ---&gt; a---+
       | 6 |
       +---+</code></pre>
            <p>Note that the “address of”, <code>&amp;</code> operator
            takes a variable and returns its address. If you print out
            the pointer, <code>printf("%p", b)</code>, you’ll get the
            address (i.e. the arrow) To <em>follow the arrow</em>, you
            must <em>dereference</em> the pointer:
            <code>*b == 6</code>.</p>
            <div class="sourceCode" id="cb17"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">/* here, the `*` is part of the type &quot;int *&quot;, i.e. a pointer to an `int` */</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>ptr<span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">     * Here, the `*` is the dereference operation, and</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">     * gives us the value that is pointed to.</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ptr <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;value is initialized to </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">(&amp;</span>value<span class="op">);</span> <span class="co">/* `&amp;` gives us the address of the variable `value` */</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;value updated to </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x100dc6f00
Strings: hello world</code></pre>
            <p>Pointers are <em>necessary</em> as they enable us to
            build <em>linked</em> data-structures (linked-lists, binary
            trees, etc…). Languages such as Java assume that <em>every
            single</em> object variable is a pointer, and since <em>all
            object variables</em> are pointers, they don’t need special
            syntax for them.</p>
            <p>Arrays are simple contiguous data items, all of the same
            type. <code>int a[4] = {6, 7, 8, 9}</code> should be
            imagined as:</p>
            <pre><code>a ---&gt; +---+---+---+---+
       | 6 | 7 | 8 | 9 |
       +---+---+---+---+</code></pre>
            <p>When you access an array item, <code>a[2] == 8</code>, C
            is really treating <code>a</code> as a pointer, doing
            pointer arithmetic, and dereferences to find offset
            <code>2</code>.</p>
            <div class="sourceCode" id="cb20"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">};</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;0th index: </span><span class="sc">%p</span><span class="st"> == </span><span class="sc">%p</span><span class="st">; </span><span class="sc">%d</span><span class="st"> == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span>     <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="op">*</span>a<span class="op">,</span>       a<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;nth index: </span><span class="sc">%p</span><span class="st"> == </span><span class="sc">%p</span><span class="st">; </span><span class="sc">%d</span><span class="st"> == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> a <span class="op">+</span> n<span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span>n<span class="op">],</span> <span class="op">*(</span>a <span class="op">+</span> n<span class="op">),</span> a<span class="op">[</span>n<span class="op">]);</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x100897f00
Strings: hello world</code></pre>
            <p>Making this a little more clear, lets understand how C
            accesses the <code>n</code>th item. Lets make a pointer
            <code>int *p = a + 1</code> (we’ll just simply and assume
            that <code>n == 1</code> here), we should have this:</p>
            <pre><code>p ---------+
           |
           V
a ---&gt; +---+---+---+---+
       | 6 | 7 | 8 | 9 |
       +---+---+---+---+</code></pre>
            <p>Thus if we dereference <code>p</code>, we access the
            <code>1</code>st index, and access the value
            <code>7</code>.</p>
            <div class="sourceCode" id="cb23"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">};</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* same thing as the previous example, just making the pointer explicit */</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;nth index: </span><span class="sc">%p</span><span class="st"> == </span><span class="sc">%p</span><span class="st">; </span><span class="sc">%d</span><span class="st"> == </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">,</span> <span class="op">&amp;</span>a<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="op">*</span>p<span class="op">,</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x1049aef00
Strings: hello world</code></pre>
            <p>We can see that <em>pointer arithmetic</em> (i.e. doing
            addition/subtraction on pointers) does the same thing as
            array indexing plus a dereference. That is,
            <code>*(a + 1) == a[1]</code>. For the most part, arrays and
            pointers can be viewed as very similar, with only a few
            exceptions<a href="#fn3" class="footnote-ref" id="fnref3"
            role="doc-noteref"><sup>3</sup></a>.</p>
            <p><em>Pointer arithmetic should generally be avoided in
            favor of using the array syntax.</em> One complication for
            pointer arithmetic is that it does not fit our intuition for
            addition:</p>
            <div class="sourceCode" id="cb25"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">};</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> b<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;b&#39;</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">,</span> <span class="ch">&#39;d&#39;</span><span class="op">};</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">     * Calculation: How big is the array?</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="co">     * How big is each item? The division is the number of items.</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_items <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_items<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;idx </span><span class="sc">%d</span><span class="st"> @ </span><span class="sc">%p</span><span class="st"> &amp; </span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> a <span class="op">+</span> i<span class="op">,</span> b <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x10093bf00
Strings: hello world</code></pre>
            <p>Note that the pointer for the integer array
            (<code>a</code>) is being incremented by 4, while the
            character array (<code>b</code>) by 1. Focusing on the key
            part:</p>
            <pre><code>idx 0 @ ...0 &amp; ...4
idx 1 @ ...4 &amp; ...5
idx 2 @ ...8 &amp; ...6
idx 3 @ ...c &amp; ...7
           ^      ^
           |      |
Adds 4 ----+      |
Adds 1 -----------+</code></pre>
            <p>Thus, pointer arithmetic depends on the <em>size of the
            types within the array</em>. There are types when one wants
            to iterate through each byte of an array, even if the array
            contains larger values such as integers. For example, the
            <code>memset</code> and <code>memcmp</code> functions set
            each byte in an range of memory, and byte-wise compare two
            ranges of memory. In such cases, <em>casts</em> can be used
            to manipulate the pointer type (e.g. <code>(char *)a</code>
            enables <code>a</code> to not be referenced with pointer
            arithmetic that iterates through bytes).</p>
            <h4 data-number="2.2.5.1" id="example-2"><span
            class="header-section-number">2.2.5.1</span> Example</h4>
            <div class="sourceCode" id="cb28"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* a simple linked list */</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> student <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> student <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> student students<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{.</span>name <span class="op">=</span> <span class="st">&quot;Penny&quot;</span><span class="op">,</span> <span class="op">.</span>next <span class="op">=</span> <span class="op">&amp;</span>students<span class="op">[</span><span class="dv">1</span><span class="op">]},</span> <span class="co">/* or `students + 1` */</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">{.</span>name <span class="op">=</span> <span class="st">&quot;Gabe&quot;</span><span class="op">,</span>  <span class="op">.</span>next <span class="op">=</span> NULL<span class="op">}</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> student <span class="op">*</span>head <span class="op">=</span> students<span class="op">;</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * head --&gt; students+------+</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="co"> *          | Penny | Gabe |</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="co"> *          | next  | next |</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="co"> *          +-|-----+---|--+</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="co"> *            |     ^   +-----&gt;NULL</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a><span class="co"> *            |     |</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="co"> *            +-----+</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> student <span class="op">*</span>i<span class="op">;</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> head<span class="op">;</span> i <span class="op">!=</span> NULL<span class="op">;</span> i <span class="op">=</span> i<span class="op">-&gt;</span>next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">-&gt;</span>name<span class="op">);</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code>Integers: 2147483647, 9223372036854775807, 4294967295, *
Hex and pointers: 7fffffffffffffff, 0x102f1af00
Strings: hello world</code></pre>
            <h4 data-number="2.2.5.2" id="generic-pointer-types"><span
            class="header-section-number">2.2.5.2</span> Generic Pointer
            Types</h4>
            <p>Generally, if you want to treat a pointer type as
            another, you need to use a cast. You rarely want to do this
            (see the <code>memset</code> example below to see an example
            where you might want it). However, there is a need in C to
            have a “generic pointer type” that can be implicitly cast
            into any other pointer type. To get a sense of why this is,
            two simple examples:</p>
            <blockquote>
            <ol type="1">
            <li>What should the type of <code>NULL</code> be?</li>
            </ol>
            </blockquote>
            <p><code>NULL</code> is used as a valid value for
            <em>any</em> pointer (of any type), thus <code>NULL</code>
            must have a generic type that can be used in the code as a
            value for any pointer. Thus, the type of <code>NULL</code>
            must be <code>void *</code>.</p>
            <blockquote>
            <ol start="2" type="1">
            <li><code>malloc</code> returns a pointer to newly-allocated
            memory. What should the type of the return value be?</li>
            </ol>
            </blockquote>
            <p>C solves this with the <code>void *</code> pointer type.
            Recall that <code>void</code> is not a valid type for a
            variable, but a <code>void *</code> is different. It is a
            “generic pointer that cannot be dereferenced*. Note that
            dereferencing a <code>void *</code> pointer shouldn’t work
            as <code>void</code> is not a valid variable type
            (e.g. <code>void *a; *a = 10;</code> doesn’t make much sense
            because <code>*a</code> is type <code>void</code>).</p>
            <div class="sourceCode" id="cb30"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>intptr <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span> <span class="co">/* malloc returns `void *`! */</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>intptr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>intptr<span class="op">;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <p>Data-structures often aim to store data of any type
            (think: a linked list of anything). Thus, in C, you often
            see <code>void *</code>s to reference the data they
            store.</p>
            <h4 data-number="2.2.5.3"
            id="relationship-between-pointers-arrays-and-arrows"><span
            class="header-section-number">2.2.5.3</span> Relationship
            between Pointers, Arrays, and Arrows</h4>
            <p>Indexing into arrays (<code>a[b]</code>) and arrows
            (<code>a-&gt;b</code>) are redundant syntactic features, but
            they are very convenient.</p>
            <ul>
            <li><code>&amp;a[b]</code> is equivalent to
            <code>a + b</code> where <code>a</code> is a pointer and
            <code>b</code> is an index.</li>
            <li><code>a[b]</code> is equivalent to <code>*(a + b)</code>
            where <code>a</code> is a pointer and <code>b</code> is an
            index.</li>
            <li><code>a-&gt;b</code> is equivalent to
            <code>(*a).b</code> where <code>a</code> is a pointer to a
            variable with a structure type that has <code>b</code> as a
            field.</li>
            </ul>
            <p>Generally, you should always try and stick to the array
            and arrow syntax were possible, as it makes your intention
            much more clear when coding than the pointer arithmetic and
            dereferences.</p>
            <h2 data-number="2.3" id="memory-allocation"><span
            class="header-section-number">2.3</span> Memory
            Allocation</h2>
            <p>Dynamic memory allocations</p>
            <ul>
            <li><code>void *malloc(size_t size)</code> - allocate
            <code>size</code> memory, or return <code>NULL</code>.</li>
            <li><code>void *calloc(size_t nmemb, size_t size)</code> -
            allocate <code>nmemb * size</code> bytes, and initialize
            them to <code>0</code>.</li>
            <li><code>void *realloc(void *ptr, size_t size)</code> -
            pass in a previous allocation, and <em>either</em>
            grow/shrink it to <code>size</code>, or allocate a new chunk
            of memory and copy the data in <code>ptr</code> into it.
            Return the memory of size <code>size</code>, or
            <code>NULL</code> on error.</li>
            <li><code>void free(void *ptr)</code> - deallocate
            previously allocated memory (returned from any of the
            above).</li>
            </ul>
            <p>A few things to keep in mind:</p>
            <ol type="1">
            <li>If you want to allocate an array, then you have to do
            the math yourself for the array size. For example,
            <code>int *arr = malloc(sizeof(int) * n);</code> to allocate
            an array of <code>int</code>s with a length of
            <code>n</code>.</li>
            <li><code>malloc</code> is not guaranteed to initialize its
            memory to <code>0</code>. <em>You</em> must make sure that
            your array gets initialized. It is not uncommon to do a
            <code>memset(arr, 0, sizeof(int) * n);</code> to set the
            memory <code>0</code>.</li>
            <li><code>calloc</code> is guaranteed to initialize all its
            allocated memory to <code>0</code>.</li>
            </ol>
            <h3 data-number="2.3.1" id="common-errors"><span
            class="header-section-number">2.3.1</span> Common
            Errors</h3>
            <ul>
            <li><em>Allocation error.</em> You <em>must</em> check the
            return value of memory allocation functions for
            <code>NULL</code>, and handle the error appropriately.</li>
            </ul>
            <div class="sourceCode" id="cb32"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Error: did not check return value! */</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <ul>
            <li><em>Dangling pointer.</em> If you maintain a pointer to
            a chunk of memory that you <code>free</code>, and then
            dereference that pointer, bad things can happen. The memory
            might have already been re-allocated due to another call to
            <code>malloc</code>, and is used for something completely
            different in your program. It is up to you as a programmer
            to avoid <code>free</code>ing memory until all references to
            it are dropped.</li>
            </ul>
            <div class="sourceCode" id="cb34"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>a <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Error: accessing what `a` points to after `free`! */</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <ul>
            <li><em>Memory leaks.</em> If you remove all references to
            memory, but <em>don’t</em> <code>free</code> it, then the
            memory will <em>never</em> get freed. This is a memory
            leak.</li>
            </ul>
            <div class="sourceCode" id="cb36"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>a<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> NULL<span class="op">;</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Error: never `free`d `a` and no references to it remain! */</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <ul>
            <li><em>Double <code>free</code>.</em> If you
            <code>free</code> the memory twice, bad things can happen.
            You could confuse the memory allocation logic, or you could
            accidentally <code>free</code> an allocation made after the
            first <code>free</code> was called.</li>
            </ul>
            <div class="sourceCode" id="cb38"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>a<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Error: yeah, don&#39;t do that! */</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <p><code>valgrind</code> will help you debug the last three
            of these issues, and later in the class, we’ll develop a
            library to help debug the first.</p>
            <h2 data-number="2.4" id="exercises"><span
            class="header-section-number">2.4</span> Exercises</h2>
            <h3 data-number="2.4.1"
            id="c-is-a-thin-language-layer-on-top-of-memory"><span
            class="header-section-number">2.4.1</span> C is a Thin
            Language Layer on Top of Memory</h3>
            <p>We’re going to look at a set of variables as memory. When
            variables are created globally, they are simply allocated
            into subsequent addresses.</p>
            <div class="sourceCode" id="cb40"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_values<span class="op">(</span><span class="dt">void</span><span class="op">);</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> c_a<span class="op">,</span> c_b<span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>c_c<span class="op">;</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo c <span class="op">=</span> <span class="op">(</span><span class="kw">struct</span> foo<span class="op">)</span> <span class="op">{</span> <span class="op">.</span>c_a <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> <span class="op">.</span>c_c <span class="op">=</span> <span class="op">&amp;</span>b <span class="op">};</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">char</span> end<span class="op">;</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> vars_size<span class="op">;</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>mem<span class="op">;</span></span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Q1: What would you predict the output of &amp;end - &amp;a is? */</span></span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Addresses:</span><span class="sc">\n</span><span class="st">a   @ </span><span class="sc">%p\n</span><span class="st">b   @ </span><span class="sc">%p\n</span><span class="st">c   @ </span><span class="sc">%p\n</span><span class="st">end @ </span><span class="sc">%p\n</span><span class="st">&quot;</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;&amp;end - &amp;a = </span><span class="sc">%ld\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="co">/* Note: you can split strings! */</span></span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>           <span class="op">&amp;</span>a<span class="op">,</span> <span class="op">&amp;</span>b<span class="op">,</span> <span class="op">&amp;</span>c<span class="op">,</span> <span class="op">&amp;</span>end<span class="op">,</span> <span class="op">&amp;</span>end <span class="op">-</span> <span class="op">&amp;</span>a<span class="op">);</span></span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Initial values:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>    print_values<span class="op">();</span></span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Q2: Describe what these next two lines are doing. */</span></span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>    vars_size <span class="op">=</span> <span class="op">&amp;</span>end <span class="op">-</span> <span class="op">&amp;</span>a<span class="op">;</span></span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>    mem <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span></span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Q3: What would you expect in the following printout (with the print uncommented)? */</span></span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">Print out the variables as raw memory</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> vars_size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">char</span> c <span class="op">=</span> mem<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a><span class="co">//      printf(&quot;%x &quot;, c);</span></span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Q4: What would you expect in the following printout (with the print uncommented)? */</span></span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>    memset<span class="op">(</span>mem<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> vars_size<span class="op">);</span></span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* memset(a, b, c): set the memory starting at `a` of size `c` equal `b` */</span></span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">Post-`memset` values:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a><span class="co">//  print_values();</span></span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>print_values<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;a     = </span><span class="sc">%d\n</span><span class="st">b     = </span><span class="sc">%d\n</span><span class="st">c.c_a = </span><span class="sc">%ld\n</span><span class="st">c.c_b = </span><span class="sc">%ld\n</span><span class="st">c.c_c = </span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>           a<span class="op">,</span> b<span class="op">,</span> c<span class="op">.</span>c_a<span class="op">,</span> c<span class="op">.</span>c_b<span class="op">,</span> c<span class="op">.</span>c_c<span class="op">);</span></span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <p><strong>Question</strong> Answer <em>Q1-4</em> in the
            code, uncommenting and modifying where appropriate.</p>
            <h4 data-number="2.4.1.1" id="takeaways"><span
            class="header-section-number">2.4.1.1</span> Takeaways</h4>
            <ol type="1">
            <li>Each variable in C (including fields in structs) want to
            be aligned on a boundary equal to the variable’s type’s
            size. This means that a variable (<code>b</code>) with an
            integer type (<code>sizeof(int) == 4</code>) should always
            have an address that is a multiple of its size
            (<code>&amp;b % sizeof(b) == 0</code>, so an
            <code>int</code>’s address is always divisible by
            <code>4</code>, a <code>long</code>’s by
            <code>8</code>).</li>
            <li>The operation to figure out the size of all the
            variables, <code>&amp;end - &amp;a</code>, is
            <em>crazy</em>. We’re used to performing math operations
            values on things of the same type, but not on
            <em>pointers</em>. This is only possible because C sees the
            variables are chunks of memory that happen to be laid out in
            memory, one after the other.</li>
            <li>The <em>crazy</em> increases with
            <code>mem = &amp;a</code>, and our iteration through
            <code>mem[i]</code>. We’re able to completely ignore the
            types in C, and access memory directly!</li>
            </ol>
            <p><strong>Question</strong>: What would break if we changed
            <code>char a;</code> into <code>int a;</code>? C doesn’t let
            us do math on variables of <em>any type</em>. If you fixed
            compilation problems, would you still get the same
            output?</p>
            <h3 data-number="2.4.2"
            id="quick-and-dirty-key-value-store"><span
            class="header-section-number">2.4.2</span> Quick-and-dirty
            Key-Value Store</h3>
            <p>Please read the <code>man</code> pages for
            <code>lsearch</code> and <code>lfind</code>.
            <code>man</code> pages can be pretty cryptic, and you are
            aiming to get <em>some idea</em> where to start with an
            implementation. An simplistic, and incomplete initial
            implementation:</p>
            <div class="sourceCode" id="cb42"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;search.h&gt;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NUM_ENTRIES </span><span class="dv">8</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kv_entry <span class="op">{</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> key<span class="op">;</span> <span class="co">/* only support keys for now... */</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="co">/* global values are initialized to `0` */</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kv_entry entries<span class="op">[</span>NUM_ENTRIES<span class="op">];</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="dt">size_t</span> num_items <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * Insert into the key-value store the `key` and `value`.</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * Return `0` on successful insertion of the value, or `-1`</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="co"> * if the value couldn&#39;t be inserted.</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>put<span class="op">(</span><span class="dt">int</span> key<span class="op">,</span> <span class="dt">int</span> value<span class="op">)</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a><span class="co"> * Attempt to get a value associated with a `key`.</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * Return the value, or `0` if the `key` isn&#39;t in the store.</span></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>get<span class="op">(</span><span class="dt">int</span> key<span class="op">)</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a>compare<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* We know these are `int`s, so treat them as such! */</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="kw">struct</span> kv_entry <span class="op">*</span>a_ent <span class="op">=</span> a<span class="op">,</span> <span class="op">*</span>b_ent <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>a_ent<span class="op">-&gt;</span>key <span class="op">==</span> b_ent<span class="op">-&gt;</span>key<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> kv_entry keys<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a>        <span class="op">{.</span>key <span class="op">=</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">{.</span>key <span class="op">=</span> <span class="dv">2</span><span class="op">},</span></span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">{.</span>key <span class="op">=</span> <span class="dv">4</span><span class="op">},</span></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">{.</span>key <span class="op">=</span> <span class="dv">3</span><span class="op">}</span></span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_kv <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>keys<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>keys<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> queries<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> num_queries <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>queries<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>queries<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Insert the keys. */</span></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_kv<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a>        lsearch<span class="op">(&amp;</span>keys<span class="op">[</span>i<span class="op">],</span> entries<span class="op">,</span> <span class="op">&amp;</span>num_items<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>entries<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>entries<span class="op">[</span><span class="dv">0</span><span class="op">]),</span> compare<span class="op">);</span></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Now lets lookup the keys. */</span></span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> num_queries<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> kv_entry <span class="op">*</span>ent<span class="op">;</span></span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> val <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a>        ent <span class="op">=</span> lfind<span class="op">(&amp;</span>queries<span class="op">[</span>i<span class="op">],</span> entries<span class="op">,</span> <span class="op">&amp;</span>num_items<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>entries<span class="op">[</span><span class="dv">0</span><span class="op">]),</span> compare<span class="op">);</span></span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>ent <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>            val <span class="op">=</span> ent<span class="op">-&gt;</span>key<span class="op">;</span></span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%d</span><span class="st"> @ </span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> val<span class="op">,</span> ent<span class="op">);</span></span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Program output:</p>
            <pre><code></code></pre>
            <p>You want to implement a simple “key-value” store that is
            very similar in API to a hash-table (many key-value stores
            are implemented using hash-tables!).</p>
            <p><strong>Questions/Tasks:</strong></p>
            <ul>
            <li><em>Q1</em>: What is the difference between
            <code>lsearch</code> and <code>lfind</code>? The
            <code>man</code>pages should help here
            (<code>man 3 lsearch</code>) (you can exit from a
            <code>man</code> page using ‘q’). What operations would you
            want to perform with each (and why)?</li>
            <li><em>Q2</em>: The current implementation doesn’t include
            <em>values</em> at all. It returns the keys instead of
            values. Expand the implementation to properly track
            values.</li>
            <li><em>Q3</em>: Encapsulate the key-value store behind the
            <code>put</code> and <code>get</code> functions.</li>
            <li><em>Q4</em>: Add testing into the <code>main</code> for
            the relevant conditions and failures in <code>get</code> and
            <code>put</code>. # Pointers | Casting <a
            href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/pointer_casting.html/">Slides</a></li>
            </ul>
            <h2 data-number="2.5" id="pointers-and-arrays"><span
            class="header-section-number">2.5</span> Pointers and
            Arrays</h2>
            <p>..are the same thing!</p>
            <ul>
            <li>just different conventions to <strong>access
            memory</strong></li>
            <li><em>e.g.,</em> pointer arithmetic over an array of
            ints</li>
            <li>moves addresses by <strong>size of the int</strong> →
            <code>4</code> bytes</li>
            <li><strong>no interaction</strong> with individual bytes
            <ul>
            <li>only <strong>whole ints</strong></li>
            </ul></li>
            </ul>
            <h2 data-number="2.6" id="pointer-arithmetic"><span
            class="header-section-number">2.6</span> Pointer
            Arithmetic</h2>
            <ul>
            <li>consider an integer array → <code>int a[5]</code></li>
            <li><code>5</code> ints, <strong>each</strong> of
            <code>4</code> bytes <img
            src="./figures/07.01.pointer_cast/pointer_cast.1.png"
            alt="array of integers" /></li>
            </ul>
            <p><br></p>
            <ul>
            <li>so <code>a[0]</code> is: <img
            src="./figures/07.01.pointer_cast/pointer_cast.2.png"
            alt="array of integers" /></li>
            </ul>
            <p><br></p>
            <ul>
            <li>so <code>a[1]</code> is → <strong>same</strong> as
            <code>++a</code>! <img
            src="./figures/07.01.pointer_cast/pointer_cast.3.png"
            alt="array of integers" /></li>
            </ul>
            <p><br></p>
            <ul>
            <li>we <strong>cannot</strong> access the individual bytes,
            i.e., these ones: <img
            src="./figures/07.01.pointer_cast/pointer_cast.4.png"
            alt="array of integers" /></li>
            </ul>
            <p><br></p>
            <p>what if we <strong>want</strong> to access the individual
            bytes?</p>
            <h2 data-number="2.7" id="pointer-casting"><span
            class="header-section-number">2.7</span> Pointer
            Casting!</h2>
            <ul>
            <li>can cast from one pointer type to another!</li>
            <li>between <strong>any two pointers</strong>!</li>
            <li>a pointer is always the same size, <em>i.e.,</em>
            <code>4</code> bytes</li>
            <li>making it point to something else</li>
            <li>doesn’t change the memory underneath
            <ul>
            <li>but, <strong>changes pointer arithmetic</strong>!</li>
            </ul></li>
            </ul>
            <h3 data-number="2.7.1" id="casting-from-int-to-char"><span
            class="header-section-number">2.7.1</span> Casting from
            <code>int*</code> to <code>char*</code></h3>
            <ul>
            <li><p>now, as before, if we have →
            <code>int a[5]</code></p></li>
            <li><p>and we do,
            <strong><code>char* pc = (char*) a ;</code></strong></p></li>
            <li><p><code>pc</code> points to the <strong>same</strong>
            memory region as <code>a</code></p></li>
            <li><p>but now, can treat it as
            <strong>characters</strong></p></li>
            <li><p><em>i.e.,</em> <strong>one byte</strong> <br>
            <br></p></li>
            <li><p>so <code>pc[0]</code> is: <img
            src="./figures/07.01.pointer_cast/pointer_cast.5.png"
            alt="array of integers" /></p></li>
            </ul>
            <p><br></p>
            <ul>
            <li>so <code>pc[1]</code> is → same as <code>++pc</code>!
            <img src="./figures/07.01.pointer_cast/pointer_cast.6.png"
            alt="array of integers" /></li>
            </ul>
            <h3 data-number="2.7.2" id="example-3"><span
            class="header-section-number">2.7.2</span> Example</h3>
            <p>Consider the following code:</p>
            <div class="sourceCode" id="cb44"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> a <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span>malloc<span class="op">(</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>a <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">;</span> <span class="co">// SAME as assert (a)</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="dv">1145258561</span> <span class="op">;</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;a = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>a <span class="op">)</span> <span class="op">;</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> ppc <span class="op">=</span> <span class="op">(</span><span class="dt">char</span><span class="op">*)</span> a <span class="op">;</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">);</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">%c</span><span class="st"> &quot;</span><span class="op">,</span> <span class="op">*</span>pc<span class="op">++</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span></span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <h2 data-number="2.8" id="pointer-casting-void"><span
            class="header-section-number">2.8</span> Pointer Casting |
            <code>void*</code></h2>
            <ul>
            <li>can cast <strong>any</strong> point to a
            <code>void*</code></li>
            <li>all of these are valid:</li>
            </ul>
            <div class="sourceCode" id="cb45"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span><span class="op">*</span> pv <span class="op">=</span> malloc<span class="op">(</span><span class="dv">32</span><span class="op">);</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> pi <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span> pv <span class="op">;</span> </span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span><span class="op">*</span> pd <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">*)</span> pv <span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span><span class="op">*</span> pc <span class="op">=</span> <span class="op">(</span><span class="dt">char</span><span class="op">*)</span> pi <span class="op">;</span> </span></code></pre></div>
            <ul>
            <li>can cast <strong>any</strong> point to a
            <code>void*</code></li>
            <li>all of these are valid:</li>
            <li><strong>cannot</strong> dereference a <code>void*</code>
            directly! compiler does not know the type</li>
            </ul>
            <h1 data-number="3" id="function-pointers"><span
            class="header-section-number">3</span> Function
            Pointers</h1>
            <p>Functions have <strong>types</strong> too. E.g.,</p>
            <div class="sourceCode" id="cb46"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">int</span> i<span class="op">,</span> <span class="dt">double</span> d<span class="op">){...}</span></span></code></pre></div>
            <p>The “type” of this function is: * takes as input two
            arguments → one <code>int</code> and one <code>double</code>
            * returns nothing, hence return type is <code>void</code> *
            <strong>note</strong>: this is <strong>not</strong> the same
            as a return type of <code>void*</code></p>
            <p>Sometimes, you need to decide <em>which</em> function to
            call at <strong>run time</strong>. Why?</p>
            <h3 data-number="3.0.1" id="example-bubble-sort"><span
            class="header-section-number">3.0.1</span> Example | Bubble
            Sort</h3>
            <p>[<a
            href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/code/generic_bubble_sort.c">Follow
            along with the Generic Bubble Sort Code</a>]</p>
            <p>How do you write a bubble sort? Say for an array of
            <code>int</code>s?</p>
            <div class="sourceCode" id="cb47"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Sorting ints</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_int<span class="op">(</span> <span class="dt">int</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">)</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> array<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">)</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> temp <span class="op">=</span> array<span class="op">[</span>j<span class="op">]</span> <span class="op">;</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>                array<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">;</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>                array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> temp <span class="op">;</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a><span class="co">// printing out an array</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_array<span class="op">(</span> <span class="dt">int</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">)</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;array = &quot;</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,</span> array<span class="op">[</span>i<span class="op">]</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> my_array<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">2341</span><span class="op">,</span> <span class="dv">8632</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2344</span><span class="op">,</span> <span class="dv">747645</span> <span class="op">}</span> <span class="op">;</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> array_size <span class="op">=</span> <span class="dv">5</span> <span class="op">;</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sort the array</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>    bubble_sort<span class="op">(</span> my_array<span class="op">,</span> array_size <span class="op">)</span> <span class="op">;</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>    print_array<span class="op">(</span> my_array<span class="op">,</span> array_size <span class="op">)</span> <span class="op">;</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>This works for an array of <code>int</code>s. But what if
            I want to sort an array of <code>double</code>?</p>
            <p>Maybe, write a new function to do that?</p>
            <div class="sourceCode" id="cb48"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sorting ints</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_double<span class="op">(</span> <span class="dt">double</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">)</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> array<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">)</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>                <span class="dt">double</span> temp <span class="op">=</span> array<span class="op">[</span>j<span class="op">]</span> <span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>                array<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">;</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>                array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> temp <span class="op">;</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>But what if I want to sort an array of <code>char</code>?
            Strings? <code>float</code>s? My custom
            <code>struct</code>s? Do we write one function for each?</p>
            <div class="sourceCode" id="cb49"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_char<span class="op">(</span> <span class="dt">char</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">){...}</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_strings<span class="op">(</span> <span class="dt">char</span><span class="op">*</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">){...}</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_float<span class="op">(</span> <span class="dt">float</span> array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">){...}</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> bubble_sort_struct_student<span class="op">(</span> <span class="kw">struct</span> student array<span class="op">[],</span> <span class="dt">int</span> array_size <span class="op">){...}</span></span></code></pre></div>
            <p>But what if <strong>we don’t know which one will be
            needed until run time?</strong>*</p>
            <p>So, depending on the data that we’re given, or some input
            from the user, we may have to pick one of the above but
            <em>won’t know of the choice at compile time</em>.</p>
            <p>Enter <strong>function pointers</strong>!</p>
            <h3 data-number="3.0.2"
            id="example-generic-bubble-sort"><span
            class="header-section-number">3.0.2</span> Example | Generic
            Bubble Sort</h3>
            <p>A sorting algorithm, at its heart, has two parts:</p>
            <ol type="1">
            <li><em>compare</em>: given two elements, let us know which
            is larger/greater</li>
            <li><em>swap</em>: given two elements, exchange their
            values</li>
            </ol>
            <p>so, in a generic sense, we have:</p>
            <div class="sourceCode" id="cb50"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span> is_greater<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">)</span> <span class="co">// If a is larger than b</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    swap<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span>         <span class="co">// swap their values</span></span></code></pre></div>
            <p>hence, we can rewrite the bubble sort function, in a
            “generic” form as:</p>
            <div class="sourceCode" id="cb51"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sorting | Generic</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(...)</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> is_greater<span class="op">(</span> array<span class="op">[</span>j<span class="op">],</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">])</span> <span class="op">)</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                swap<span class="op">(</span> array<span class="op">[</span>j<span class="op">],</span> array<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>But, what are the <strong>inputs</strong> to the
            function?</p>
            <p>We first need to define the type of the array. Since we
            won’t know the type of the data elements in the array, we
            can’t pick a specific array type.</p>
            <p>But, remember: * arrays and pointers are interchangeable
            * can cast from any pointer type to <code>void*</code> and
            back</p>
            <p>using this, we define the array as a
            <code>void*</code>:</p>
            <div class="sourceCode" id="cb52"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="op">...</span> <span class="op">)</span></span></code></pre></div>
            <p>As before, we need to know the <em>size</em> of the
            entire array, so we can now expand the function signature
            more:</p>
            <div class="sourceCode" id="cb53"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> <span class="op">...)</span></span></code></pre></div>
            <p>Remember that a void* pointer is just a pointer to a
            <em>block</em> of memory. C does not know the <em>type of
            each element</em> in the array. So, we
            <strong>cannot</strong> do: * <code>array[i]</code> → since
            the type is a <code>void*</code></p>
            <p>We can use pointer arithmetic with <code>void*</code> so
            this is possible: * <code>array+i</code> → but that moves
            the pointer forward by <code>i</code>
            <strong>bytes</strong></p>
            <p>and <strong>not</strong> by the number of bytes of the
            data type. Recall, * <code>char* pc ; pc+1 ;</code> →
            advances by <code>1</code> byte *
            <code>int* pi ; pi+1 ;</code> → advances by <code>4</code>
            bytes</p>
            <p>Hence, we need information about the <em>size of each
            element</em>, i.e.,</p>
            <div class="sourceCode" id="cb54"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> </span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>                                        <span class="dt">int</span> element_size <span class="op">)</span> </span></code></pre></div>
            <p>So, we can do: <code>array + (i * element_size)</code> to
            move to the next element in the array</p>
            <p>So, for an <code>int</code> array, we get
            (<code>element_size = 4</code>): <img
            src="./figures/07.01.pointer_cast/pointer_cast.2.png"
            alt="array of integers" /> <img
            src="./figures/07.01.pointer_cast/pointer_cast.3.png"
            alt="array of integers" /> <br></p>
            <p>and for a <code>char</code> array, we get
            (<code>element_size = 1</code>): <img
            src="./figures/07.01.pointer_cast/pointer_cast.5.png"
            alt="array of integers" /> <img
            src="./figures/07.01.pointer_cast/pointer_cast.6.png"
            alt="array of integers" /></p>
            <p><br></p>
            <p>Using this information about <code>element_size</code>,
            we can rewrite the generic bubble sort function as:</p>
            <div class="sourceCode" id="cb55"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sorting | Generic</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> </span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                                        <span class="dt">int</span> element_size <span class="op">)</span> </span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> is_greater<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>                swap<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Now we see the <em>generic</em> version of bubble sort
            taking shape.</p>
            <h3 data-number="3.0.3" id="what-is-generic"><span
            class="header-section-number">3.0.3</span> What is
            “<em>generic</em>”?</h3>
            <p>But we are still missing critical information,
            <em>viz.</em>, what are <code>is_greater()</code> and
            <code>swap()</code>?</p>
            <p>Remember that since the
            <code>generic_bubble_sort()</code> function doesn’t know
            which <em>exact</em> type it is operating on, we need to
            <em>somehow</em> provide it with the <strong>actual</strong>
            functions that will carry out the comparison and swapping,
            depending on the type of the array being passed in. For
            instance, if we are comparing integers, we need a comparator
            and swap that can operate on integers and similarly ones for
            structs, doubles, <em>etc.</em></p>
            <p>Wouldn’t it be great, if we could just <strong>send in
            the specific functions as arguments to
            <code>generic_bubble_sort()</code></strong>, say like,</p>
            <div class="sourceCode" id="cb56"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> </span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">int</span> element_size<span class="op">,</span> </span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>                          <span class="op">&lt;</span>SOME_TYPE<span class="op">&gt;</span> is_greater<span class="op">,</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>                          <span class="op">&lt;</span>SOME_TYPE<span class="op">&gt;</span> swap <span class="op">)</span> </span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> is_greater<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>                swap<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>This is <em>precisely</em> where <strong>function
            pointers</strong> come in.</p>
            <p>We can define <code>is_greater()</code> and
            <code>swap()</code> to be pointers to functions,
            <em>i.e.,</em> to a <strong>type</strong> of function (the
            signatures). Hence, a <em>comparator</em> function pointer
            would look like:</p>
            <div class="sourceCode" id="cb57"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>comparator_function_pointer<span class="op">)(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span> <span class="op">;</span></span></code></pre></div>
            <p>Recall that the <code>typedef</code> keyword
            <em>associates a name with a type</em>. In the above
            example, we are saying that
            <code>comparator_function_pointer</code> is now a name that
            refers to the (function) type,
            <code>int (*)( void*, void* )</code>, <em>i.e.,</em> a
            <strong>pointer to a function that takes two arguments, each
            of type <code>void*</code> and returns and
            <code>int</code></strong>.</p>
            <p>Note, that the job of a comparator function is to take
            two values and, * return positive (non-zero) values if
            <code>l &gt; r</code> or * a zero if
            <code>l &lt;= r</code>.</p>
            <p>We can define the <code>swap</code> function pointer in a
            similar manner:</p>
            <div class="sourceCode" id="cb58"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">void</span> <span class="op">(*</span>swap_function_pointer<span class="op">)(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span> <span class="op">;</span></span></code></pre></div>
            <p>where, <code>swap_function_pointer</code> is a
            <strong>name</strong> that refers to the (function) type,
            <code>void (*)( void*, void* )</code> since such a function
            doens’t need to return anything, just swap the two elements
            pointed to by the <code>void*</code> arguments.</p>
            <p>Updating our sorting function to use the function
            pointers,</p>
            <div class="sourceCode" id="cb59"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_bubble_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> </span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">int</span> element_size<span class="op">,</span> </span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>                          comparator_function_pointer is_greater<span class="op">,</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>                          swap_function_pointer swap <span class="op">)</span> </span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> i <span class="op">&lt;</span> array_size<span class="op">-</span><span class="dv">1</span> <span class="op">;</span> <span class="op">++</span>i <span class="op">)</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span> <span class="dt">unsigned</span> <span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span> <span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">;</span> <span class="op">++</span>j <span class="op">)</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span> is_greater<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>                swap<span class="op">(</span> array <span class="op">+</span> <span class="op">(</span>j <span class="op">*</span> element_size<span class="op">),</span> array <span class="op">+</span> <span class="op">((</span>j<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">*</span> element_size <span class="op">))</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>So, <code>is_greater</code> is now a function pointer of
            type, <code>comparator_function_pointer</code> and
            <code>swap</code> is a function pointer of type,
            <code>swap_function_pointer</code>.</p>
            <p><strong>NOTE:</strong> function pointers are invoked
            <strong>exactly</strong> like regular functions,
            <em>i.e.,</em> <code>is_greater(...)</code> and
            <code>swap(...)</code>. The above code will work without any
            changes.</p>
            <h3 data-number="3.0.4"
            id="generic-to-concrete-functions"><span
            class="header-section-number">3.0.4</span> Generic to
            <em>concrete</em> functions</h3>
            <p>Eventually, we need to decide what it is that we are
            sorting. Is it an array of <code>int</code>s,
            <code>doubles</code>s, <code>struct</code>s, etc. And at
            that point in time, we will need the actual, **concrete*
            functions for comparing and swapping <code>int</code>s (or
            <code>double</code>s or whatever).</p>
            <p>We we define the two functions (using <code>int</code> as
            an example):</p>
            <div class="sourceCode" id="cb60"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Compare and Swap functions for integers</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> is_greater_than_int<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cast it from void* to relevant type, int*</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// since we cannot dereference void*</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> left <span class="op">=</span> l <span class="op">;</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> right <span class="op">=</span> r <span class="op">;</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// compare and return result</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="op">*</span>left <span class="op">&gt;</span> <span class="op">*</span>right <span class="op">)</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">;</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span> </span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>   <span class="co">// Can just use this one line instead but not doing so for clarity</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>   <span class="co">// return ( *l &gt; *r ? 1 : 0 ) ; </span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap_int<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// cast it from void* to relevant type, int*</span></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// since we cannot dereference void*</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> left <span class="op">=</span> l <span class="op">;</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> right <span class="op">=</span> r <span class="op">;</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> temp <span class="op">=</span> <span class="op">*</span>left <span class="op">;</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// swap</span></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>left <span class="op">=</span> <span class="op">*</span>right <span class="op">;</span></span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>right <span class="op">=</span> temp <span class="op">;</span></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>We can define equivalent functions for
            <code>double</code>,</p>
            <div class="sourceCode" id="cb61"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Compare and Swap functions for doubles </span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> is_greater_than_double<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> left <span class="op">=</span> l <span class="op">;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> right <span class="op">=</span> r <span class="op">;</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="op">*</span>left <span class="op">&gt;</span> <span class="op">*</span>right <span class="op">)</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">;</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span> </span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap_double<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> l<span class="op">,</span> <span class="dt">void</span><span class="op">*</span> r <span class="op">)</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> left <span class="op">=</span> l <span class="op">;</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span><span class="op">*</span> right <span class="op">=</span> r <span class="op">;</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> temp <span class="op">=</span> <span class="op">*</span>left <span class="op">;</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>left <span class="op">=</span> <span class="op">*</span>right <span class="op">;</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>right <span class="op">=</span> temp <span class="op">;</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p><strong>NOTE:</strong> the type signatures of the
            concrete functions must <strong>exactly match</strong> that
            of the corresponding function pointers. Otherwise it will
            result in compile time errors.</p>
            <h3 data-number="3.0.5"
            id="putting-it-all-together-using-function-pointers"><span
            class="header-section-number">3.0.5</span> Putting it all
            Together | Using Function Pointers</h3>
            <p>Now we are ready to use the concrete functions and the
            pointers in our code:</p>
            <div class="sourceCode" id="cb62"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> my_array_int<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">2341</span><span class="op">,</span> <span class="dv">8632</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2344</span><span class="op">,</span> <span class="dv">747645</span> <span class="op">}</span> <span class="op">;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> array_size <span class="op">=</span> <span class="dv">5</span> <span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calling the INTEGER version with the concrete integer comparator and swap</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>    generic_bubble_sort<span class="op">(</span> my_array_int<span class="op">,</span> array_size<span class="op">,</span> </span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">),</span> <span class="co">/*element size*/</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>                         is_greater_than_int<span class="op">,</span> </span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>                         swap_int <span class="op">)</span> <span class="op">;</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calling the DOUBLE version with the concrete DOUBLE comparator and swap</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> my_double_array<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">9485.2</span><span class="op">,</span> <span class="fl">34.567</span><span class="op">,</span> <span class="fl">9383.243</span><span class="op">,</span> <span class="fl">44.1</span> <span class="op">}</span> <span class="op">;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>    generic_bubble_sort<span class="op">(</span> my_double_array<span class="op">,</span> array_size<span class="op">,</span> </span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">sizeof</span><span class="op">(</span><span class="dt">double</span><span class="op">),</span> <span class="co">/*element size*/</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>                         is_greater_than_double<span class="op">,</span> </span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>                         swap_double <span class="op">)</span> <span class="op">;</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>As we see from the above, we are using the
            <strong>same</strong> <code>generic_bubble_srt</code>
            function to sort both, arrays of <code>int</code> and
            <code>double</code>. The only difference is the different
            <em>concrete</em> versions of the comparator and swap
            functions that we pass to the sorting function.</p>
            <h3 data-number="3.0.6"
            id="why-bother-if-we-need-concrete-functions-anyways"><span
            class="header-section-number">3.0.6</span> Why bother if we
            need <code>concrete</code> functions anyways?</h3>
            <p>Using function pointers allows us to do a few things
            well: 1. <strong>code reuse</strong>: the code for sorting
            doesn’t need to be rewritten each time. In fact, when we
            have larger, more complex, functions, this will be a
            lifesaver as we can implement the main “concept” just once
            and then write “<em>specialized</em>” concrete functions
            (usually much smaller) as needed. 2. <strong>dynamic
            dispatch</strong>: oftentimes, it may not be clear
            <em>which</em> version of the concrete functions are needed,
            <strong>until runtime</strong>! In our example, what if we
            don’t know if we’re given arrays of <code>int</code>s or
            <code>double</code>s until we receive the data at runtime?
            Then we cannot know which concrete function is to be invoked
            while writing the code. Hence, we can pick the appropriate
            function pointer <em>at run time</em> and the code will work
            correctly! 3. <strong>specialization</strong>: different
            data types require different handling. The way we sort
            numbers <em>will not</em> be the same way we sort strings or
            other, more complex, data types (<em>e.g.,</em> user defined
            <code>struct</code>s).</p>
            <h3 data-number="3.0.7"
            id="in-class-exercise-generic-insertion-sort-for-struct"><span
            class="header-section-number">3.0.7</span> In-class Exercise
            | Generic Insertion Sort for <code>struct</code></h3>
            <p>Fill out the missing elements in this code:</p>
            <div class="sourceCode" id="cb63"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define NAME_LENGTH </span><span class="dv">128</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> map<span class="op">{</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> _country<span class="op">[</span>NAME_LENGTH<span class="op">]</span> <span class="op">;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> _capital<span class="op">[</span>NAME_LENGTH<span class="op">]</span> <span class="op">;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">;</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a><span class="co">// DEFINE TWO FUNCTION POINTERS, ONE EACH FOR COMPARE AND SWAP</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a><span class="co">// UNCOMMENT THE TWO ARGUMENTS ONCE YOU DEFINE THE FUNCTION POINTERS</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> generic_insertion_sort<span class="op">(</span> <span class="dt">void</span><span class="op">*</span> array<span class="op">,</span> <span class="dt">int</span> array_size<span class="op">,</span> <span class="dt">int</span> element_size</span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>                            <span class="co">/*is_greater_than my_comparator,</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a><span class="co">                            swap my_swap*/</span> <span class="op">)</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a><span class="co">// CREATE A NEW STRUCT AND RETURN A POINTER TO IT</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> map<span class="op">*</span> create_new_struct<span class="op">(</span><span class="co">/*...*/</span><span class="op">)</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a><span class="co">// CREATE THE COMPARATOR AND SWAP FUNCTIONS HERE</span></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a><span class="co">// FUNCTION TO PRINT THE ARRAY OF STRUCTS AND ITS ELEMENTS</span></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a><span class="co">// PRINT EACH RECORD ON A NEW LINE AS FOLLOWS:</span></span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a><span class="co">// country: USA             capital: Washington D.C.</span></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a><span class="co">// country: Sierra Leone    capital: Freetown</span></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_array_structs<span class="op">(</span><span class="co">/*...*/</span><span class="op">)</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> </span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> num_countries <span class="op">;</span></span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;number of countries: &quot;</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">&amp;</span>num_countries <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CREATE AN ARRAY OF POINTERS TO STRUCTS</span></span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> map<span class="op">**</span> array_countries <span class="co">/*= ...*/</span> <span class="op">;</span></span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">// CREATE num_countries NUMBER OF &quot;COUNTRIES&quot; AND STORE IN THE ARRAY</span></span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ASK USER FOR INPUT ON COUNTRY/CAPITALS</span></span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a>    <span class="co">// YOU CAN PICK YOUR OWN COUNTRY/CAPITAL COMBINATIONS</span></span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PRINT THE ARRAY BEFORE SORT</span></span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true" tabindex="-1"></a>    print_array_structs<span class="op">(</span> <span class="co">/*...*/</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SORT THE ARRAY -- FIRST BY COUNTRY NAME</span></span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true" tabindex="-1"></a>    generic_insertion_sort<span class="op">(</span> array_countries<span class="op">,</span> num_countries<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> map<span class="op">*)</span> <span class="co">/*,...*/</span><span class="op">)</span> <span class="op">;</span> </span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PRINT THE ARRAY AFTER FIRST SORT</span></span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true" tabindex="-1"></a>    print_array_structs<span class="op">(</span> <span class="co">/*...*/</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true" tabindex="-1"></a>    <span class="co">// SORT THE ARRAY -- SECOND BY CAPITAL NAME</span></span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true" tabindex="-1"></a>    generic_insertion_sort<span class="op">(</span> array_countries<span class="op">,</span> num_countries<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> map<span class="op">*)</span> <span class="co">/*,...*/</span><span class="op">)</span> <span class="op">;</span> </span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true" tabindex="-1"></a>    <span class="co">// PRINT THE ARRAY AFTER SECOND SORT</span></span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true" tabindex="-1"></a>    print_array_structs<span class="op">(</span> <span class="co">/*...*/</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span></span>
<span id="cb63-80"><a href="#cb63-80" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <h1 data-number="4"
            id="c-memory-model-data-structures-and-apis"><span
            class="header-section-number">4</span> C Memory Model,
            Data-structures, and APIs</h1>
            <p>C presents some unique opportunities for how to structure
            your code and data-structures, but also requires that you’re
            careful about how data is passed around a program.</p>
            <h2 data-number="4.1" id="memory-allocation-options"><span
            class="header-section-number">4.1</span> Memory Allocation
            Options</h2>
            <p>In C, when creating a variable, you have the option of
            allocating it in one of multiple different types of
            memory:</p>
            <ul>
            <li>In another existing structure.</li>
            <li>In the heap using <code>malloc</code> or its sibling
            functions.</li>
            <li>In global memory.</li>
            <li>On the stack.</li>
            </ul>
            <p>It might be surprising, but it is quite <em>uncommon</em>
            in programming languages to have this flexibility.</p>
            <h3 data-number="4.1.1" id="internal-allocation"><span
            class="header-section-number">4.1.1</span> Internal
            Allocation</h3>
            <p>What does it look like to do internal allocation of one
            struct or array inside of another? See the following as an
            example.</p>
            <div class="sourceCode" id="cb64"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> bar <span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="co">     * `arr` is allocated internally to `bar`, whereas `bytes` is a pointer to</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="co">     * a separate allocation. `arr` must have a *fixed size*, and `bytes` does not</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="co">     * because its allocation can be as large as you want!</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span><span class="dv">64</span><span class="op">];</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">*</span>bytes<span class="op">;</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The `bar` structure is allocated as *part of* the `struct foo` in `internal` */</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> bar internal<span class="op">;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* But we can *also* allocate another `bar` separately if we&#39;d prefer */</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> bar <span class="op">*</span>external<span class="op">;</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a><span class="co">     * We didn&#39;t have to separately allocate the `struct bar internal` as</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a><span class="co">     * it was allocated with the enclosing `a` allocation. However, we do have to</span></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a><span class="co">     * allocate the `external` allocation. In both cases, we have access to a</span></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a><span class="co">     * `struct bar` from within `struct foo`.</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> foo <span class="op">*</span>a <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> foo<span class="op">));</span> <span class="co">/* should check return value */</span></span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>external   <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> bar<span class="op">));</span> <span class="co">/* and this one ;-( */</span></span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a><span class="co">     * Note the difference in needing to use `-&gt;` when `external` is a pointer</span></span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a><span class="co">     * versus simply using `.` with `internal`.</span></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>    a<span class="op">-&gt;</span>internal<span class="op">.</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> a<span class="op">-&gt;</span>external<span class="op">-&gt;</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>One of the more interesting uses of internal allocation
            is in linked data-structures (e.g. like linked lists). It is
            common in languages like java to implement linked
            data-structures to have “nodes” that reference the data
            being tracked.</p>
            <div class="sourceCode" id="cb65"><pre
            class="sourceCode java"><code class="sourceCode java"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This could be made generic across the data types it could store by instead</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">// using `class LinkedList&lt;T&gt;`, but I&#39;m keeping it simple here.</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LinkedListOfStudents <span class="op">{</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> head<span class="op">;</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="bu">Node</span> <span class="op">{</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>        Student s<span class="op">;</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> next<span class="op">;</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span><span class="op">(</span>Student s<span class="op">,</span> <span class="bu">Node</span> next<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">s</span>    <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">next</span> <span class="op">=</span> next<span class="op">;</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">add</span><span class="op">(</span>Student s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The program has *previously* allocated `data`.</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Now we have to additionally allocate the `node` separate from the data!</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> n <span class="op">=</span> <span class="kw">new</span><span class="op">(</span>s<span class="op">,</span> <span class="kw">this</span><span class="op">.</span><span class="fu">head</span><span class="op">);</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">head</span> <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a><span class="co">// This looks like the following. Note separate allocations for Node and Student</span></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a><span class="co">// head --&gt; Node------+    ,--&gt;Node-----+</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a><span class="co">//          | s  next |---&#39;    | s next |---...</span></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="co">//          +-|-------+        +-|------+</span></span>
<span id="cb65-31"><a href="#cb65-31" aria-hidden="true" tabindex="-1"></a><span class="co">//            v                  V</span></span>
<span id="cb65-32"><a href="#cb65-32" aria-hidden="true" tabindex="-1"></a><span class="co">//          Student-+           Student-+</span></span>
<span id="cb65-33"><a href="#cb65-33" aria-hidden="true" tabindex="-1"></a><span class="co">//          | ...   |           | ...   |</span></span>
<span id="cb65-34"><a href="#cb65-34" aria-hidden="true" tabindex="-1"></a><span class="co">//          +-------+           +-------+</span></span></code></pre></div>
            <p>Lets see the same in C.</p>
            <div class="sourceCode" id="cb66"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> linked_list_node <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> linked_list_node <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> linked_list <span class="op">{</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> linked_list_node <span class="op">*</span>head<span class="op">;</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> student <span class="op">{</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// student data here...</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> linked_list_node list<span class="op">;</span></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>add<span class="op">(</span><span class="kw">struct</span> linked_list <span class="op">*</span>ll<span class="op">,</span> <span class="kw">struct</span> linked_list_node <span class="op">*</span>n<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>data<span class="op">)</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a>    n<span class="op">-&gt;</span>next  <span class="op">=</span> ll<span class="op">-&gt;</span>head<span class="op">;</span></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>    n<span class="op">-&gt;</span>data  <span class="op">=</span> data<span class="op">;</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>    ll<span class="op">-&gt;</span>head <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> linked_list l<span class="op">;</span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> student <span class="op">*</span>s <span class="op">=</span> malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> student<span class="op">));</span></span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Should check that `s != NULL`... */</span></span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>    add<span class="op">(&amp;</span>l<span class="op">,</span> <span class="op">&amp;</span>s<span class="op">-&gt;</span>list<span class="op">,</span> s<span class="op">);</span> <span class="co">/* note that `&amp;s-&gt;list` is the same as `&amp;(s-&gt;list)` */</span></span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;student added to list!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a><span class="co"> * This looks something like the following. Linked list is *internal* to student.</span></span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a><span class="co"> * head ----&gt; student-+     ,-&gt; student-+</span></span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a><span class="co"> *            | ...   |    ,    | ...   |</span></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a><span class="co"> *            | next  |---&#39;     | next  |--&gt; NULL</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a><span class="co"> *            +-------+         +-------+</span></span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span></code></pre></div>
            <p>A few interesting things happened here:</p>
            <ol type="1">
            <li>We’re using <code>void *</code> pointers within the
            <code>linked_list_node</code> so that the linked list can
            hold data of <em>any pointer type</em>. You can see that in
            our list implementation, there is nothing that is
            <code>student</code>-specific.</li>
            <li>The <code>list</code> is inline-allocated inside the
            <code>student</code> structure, which completely avoids the
            separate <code>node</code> allocation.</li>
            </ol>
            <p>Most serious data-structure implementations enable this
            inlining of data-structure nodes even without requiring the
            <code>data</code> pointer in the node. We won’t cover that,
            but you can <a
            href="https://github.com/gwsystems/ps/blob/master/ps_list.h">see
            a sample implementation</a>.</p>
            <h3 data-number="4.1.2" id="heap-allocation"><span
            class="header-section-number">4.1.2</span> Heap
            Allocation</h3>
            <p>We’ve already seen <code>malloc</code>,
            <code>calloc</code>, <code>realloc</code>, and
            <code>free</code> which are our interface to the heap. These
            provide the most flexibility, but require that you track the
            memory and <code>free</code> it appropriately<a href="#fn4"
            class="footnote-ref" id="fnref4"
            role="doc-noteref"><sup>4</sup></a></p>
            <h3 data-number="4.1.3" id="global-allocation"><span
            class="header-section-number">4.1.3</span> Global
            Allocation</h3>
            <p>We have already seen global allocations frequently in
            examples so far.</p>
            <div class="sourceCode" id="cb67"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* A globally allocated array! No `malloc` needed! */</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span><span class="dv">64</span><span class="op">];</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> foo <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a><span class="co">/* A globally allocated structure! */</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> foo s<span class="op">;</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="co">/* Globally allocated *and* initialized integer... */</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> c <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="co">/* ...and array. */</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> d<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;What is uninitialized global memory set to?</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;Integer: </span><span class="sc">%d\n</span><span class="st">Pointer: </span><span class="sc">%p</span><span class="st"> (as hex: </span><span class="sc">%lx</span><span class="st">)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>           arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> s<span class="op">.</span>next<span class="op">,</span> <span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span><span class="op">)</span>s<span class="op">.</span>next<span class="op">);</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Note that we use `.` to access the fields because `s` is not a pointer! */</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Global variables are either initialized where they are
            defined, or are initialized to <code>0</code>. Note that
            they are intialized to all <code>0</code>s regardless their
            type. This makes more sense than it sounds because pointers
            set to <code>0</code> are <code>NULL</code> (because,
            recall, <code>NULL</code> is just <code>(void *)0</code> –
            see the “hex” output above), and because strings (see later)
            are terminated by <code>\0</code> which is also
            <code>0</code>! Thus, this policy initializes all numerical
            data to <code>0</code>, all pointers to <code>NULL</code>,
            and all strings to <code>""</code>.</p>
            <h3 data-number="4.1.4" id="stack-allocation"><span
            class="header-section-number">4.1.4</span> Stack
            Allocation</h3>
            <p>Variables can also be allocated <em>on the stack</em>.
            This effectively means that as you’re executing in a
            function, variables can be allocated within the
            context/memory of that function. An example that allocates a
            structure and an array on the stack:</p>
            <div class="sourceCode" id="cb68"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define ARR_SZ </span><span class="dv">12</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * Find an integer in the array, reset it to `0`, and return its offset.</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Nothing very interesting here.</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>find_and_reset<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>arr<span class="op">,</span> <span class="dt">int</span> val<span class="op">)</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* find the value */</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ARR_SZ<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>            arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Couldn&#39;t find it! */</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>fib<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Allocate an array onto the stack */</span></span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fibs<span class="op">[</span>ARR_SZ<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">13</span><span class="op">,</span> <span class="dv">21</span><span class="op">,</span> <span class="dv">34</span><span class="op">,</span> <span class="dv">55</span><span class="op">,</span> <span class="dv">89</span><span class="op">};</span> <span class="co">/* looks like a suspicious sequence... */</span></span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret<span class="op">;</span></span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> find_and_reset<span class="op">(</span>fibs<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* should have been set to `0`, so this should return `-1` */</span></span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>find_and_reset<span class="op">(</span>fibs<span class="op">,</span> v<span class="op">)</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret<span class="op">;</span></span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Should find 8 @ 6: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> fib<span class="op">(</span><span class="dv">8</span><span class="op">));</span></span>
<span id="cb68-44"><a href="#cb68-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* if the array was the same array for these two calls, it would be found at offset -1 (error) */</span></span>
<span id="cb68-45"><a href="#cb68-45" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Should find 8 @ 6: </span><span class="sc">%d</span><span class="st"> (-1 is wrong here)</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> fib<span class="op">(</span><span class="dv">8</span><span class="op">));</span></span>
<span id="cb68-46"><a href="#cb68-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-47"><a href="#cb68-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb68-48"><a href="#cb68-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Key points to realize:</p>
            <ul>
            <li><code>fibs</code> in <code>fib</code> is allocated
            <em>on the stack</em> and is initialized in
            <code>fib</code>!</li>
            <li>We are passing the array into
            <code>find_and_reset</code> which modifies the array
            directly as it is passed as a pointer.</li>
            <li>The first time that <code>fib</code> is called, it
            creates the <code>arr</code>. After we <em>return</em> from
            <code>fib</code>, the <code>fibs</code> goes away (strictly:
            its memory is reclaimed as part of returning from
            <code>fib</code>).</li>
            <li>The second time we call <code>fib</code>, it effectively
            is a <em>new</em> execution of <code>fib</code>, thus a
            <em>new</em> allocation of <code>fibs</code> that is now
            initialized a second time.</li>
            </ul>
            <h4 data-number="4.1.4.1" id="stack-usage-example"><span
            class="header-section-number">4.1.4.1</span> Stack Usage
            Example</h4>
            <p>How do we think about this? The stack starts out in
            <code>main</code>:</p>
            <pre><code>stack          |
|              |
+-main---------+
|              | &lt;--- main&#39;s local data (note: no local variables)
+--------------+</code></pre>
            <p>What we’re drawing here is a “<em>stack frame</em>” for
            the <code>main</code> function. This includes all of the
            local data allocated within the function, and (at least
            conceptually) also includes the arguments passed into the
            function (<code>main</code> has none). When it calls
            <code>fib</code>, a stack frame is allocated for
            <code>fib</code>, the argument is passed in, and
            <code>fib</code>s variables are allocated:</p>
            <pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| arg: v       | &lt;--- argument to fib
| fibs[ARR_SZ] | &lt;-+- local variables, allocated here!
| ret          | &lt;-&#39;
+--------------+</code></pre>
            <p><code>fib</code> calls <code>find_and_reset</code>:</p>
            <pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| v            |
| fibs[ARR_SZ] |&lt;--+
| ret          |   | pointer to fibs passed as argument, and used to update arr[v]
+find_and_reset+   |
| arg: arr     |---+
| arg: val     |
| i            |
+--------------+</code></pre>
            <p>Since <code>find_and_reset</code> updates the array in
            <code>fib</code>’s stack frame, when it returns, the array
            is still properly updated. Importantly, once we return to
            <code>main</code>, we have deallocated all of the variables
            from the previous call to <code>fib</code>…</p>
            <pre><code>stack          |
|              |
+-main---------+
|              | &lt;--- returning to main, deallocates the fibs array in fib
+--------------+</code></pre>
            <p>…thus the next call to <code>fib</code> allocates a
            <em>new</em> set of local variables including
            <code>fibs</code>.</p>
            <pre><code>stack          |
|              |
+-main---------+
|              |
+-fib----------+
| arg: v       |
| fibs[ARR_SZ] | &lt;--- new version of fibs, re-initialized when we fib is called
| ret          |
+--------------+</code></pre>
            <h4 data-number="4.1.4.2"
            id="common-errors-in-stack-allocation"><span
            class="header-section-number">4.1.4.2</span> Common Errors
            in Stack Allocation</h4>
            <p>A few common errors with stack allocation include:</p>
            <ul>
            <li><em>Uninitialized variables.</em> You must
            <em>always</em> initialize all variables allocated on the
            stack, otherwise they can contain seemingly random values
            (see below).</li>
            <li><em>Pointers to stack allocated variables after
            return.</em> After a function returns, its stack allocated
            variables are no longer valid (they were deallocated upon
            <code>return</code>). Any pointers that remain to any of
            those variables are no longer pointing to valid memory!</li>
            </ul>
            <p>We discuss these next.</p>
            <p><strong>Initializing stack-allocated variables.</strong>
            For global memory, we saw that variables, if not
            intentionally initialized, would be set to <code>0</code>.
            This is <em>not</em> the case with stack allocated
            variables. In fact, the answer is “it depends”. If you
            compile your code without optimizations, stack allocated
            variables will be initialized to <code>0</code>; if you
            compile with optimizations, they are <em>not</em>
            initialized. Yikes. Thus, we must assume that they are not
            automatically initialized (similar to the memory returned
            from <code>malloc</code>). An example:</p>
            <div class="sourceCode" id="cb74"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* don&#39;t manually initialize anything here */</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[</span><span class="dv">12</span><span class="op">];</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">12</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">();</span></span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Yikes. We’re getting random values in the array! Where do
            you think these values came from?</p>
            <p><strong>References to stack variables after function
            return.</strong></p>
            <div class="sourceCode" id="cb75"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="op">*</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>bar<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>a<span class="op">;</span>            <span class="co">/* Return the address of a local variable. */</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a>foo<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span> <span class="co">/* Allocate `a` on the stack here... */</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">=</span> <span class="op">&amp;</span>a<span class="op">;</span>             <span class="co">/* ...and set the global pointer to point to it... */</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span>               <span class="co">/* ...but then we deallocate `a` when we return. */</span></span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> val<span class="op">;</span></span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>    foo<span class="op">();</span></span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Save address of local variable, and dereference it: </span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>ptr<span class="op">);</span></span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a>    fflush<span class="op">(</span>stdout<span class="op">);</span> <span class="co">/* ignore this ;-) magic sprinkles here */</span></span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">=</span> bar<span class="op">();</span></span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Return address of local variable, and dereference it: </span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>ptr<span class="op">);</span></span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb75-35"><a href="#cb75-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>You can see a few interesting facts from the output.</p>
            <ol type="1">
            <li>The value referenced by <code>*ptr</code> after
            <code>foo</code> is a random value, and dereferencing the
            return value from<code>bar</code> causes a segmentation
            fault.</li>
            <li><code>foo</code> and <code>bar</code> contain logic that
            feels pretty identical. In either case, they are taking a
            local variable, and passing its address to <code>main</code>
            where it is used. <code>foo</code> passed it through a
            global variable, and <code>bar</code> simply returns the
            address. Despite this, one of them causes a segmentation
            fault, and the other seems to return a nonsensical value!
            When you try and use stack allocated variables after they
            are been freed (by their function returning), you get
            <em>unpredictable</em> results.</li>
            <li>The C compiler is aggressive about issuing warnings as
            it can tell that bad things are afoot. Warnings are your
            friend and you <em>must</em> do your development with them
            enabled.</li>
            </ol>
            <p>Stack allocation is powerful, can be quite useful.
            However, you have to always be careful that stack allocated
            variables are never added into global data-structures, and
            are never returned.</p>
            <h3 data-number="4.1.5" id="putting-it-all-together"><span
            class="header-section-number">4.1.5</span> Putting it all
            Together</h3>
            <p>Lets look at an example that uses inlined, global, and
            stack allocation. We’ll avoid heap-based allocation to
            demonstrate the less normal memory allocation options in
            C.</p>
            <div class="sourceCode" id="cb76"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;search.h&gt;</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kv_entry <span class="op">{</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> key<span class="op">;</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>value<span class="op">;</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> kv_store <span class="op">{</span></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* internal allocation of the key-value store&#39;s entries */</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> kv_entry entries<span class="op">[</span><span class="dv">16</span><span class="op">];</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> num_entries<span class="op">;</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb76-17"><a href="#cb76-17" aria-hidden="true" tabindex="-1"></a>kv_comp<span class="op">(</span><span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">const</span> <span class="dt">void</span> <span class="op">*</span>b<span class="op">)</span></span>
<span id="cb76-18"><a href="#cb76-18" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb76-19"><a href="#cb76-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="kw">struct</span> kv_entry <span class="op">*</span>a_ent <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb76-20"><a href="#cb76-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="kw">struct</span> kv_entry <span class="op">*</span>b_ent <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb76-21"><a href="#cb76-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-22"><a href="#cb76-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Compare keys, and return `0` if they are the same */</span></span>
<span id="cb76-23"><a href="#cb76-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">!(</span>a_ent<span class="op">-&gt;</span>key <span class="op">==</span> b_ent<span class="op">-&gt;</span>key<span class="op">);</span></span>
<span id="cb76-24"><a href="#cb76-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-25"><a href="#cb76-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-26"><a href="#cb76-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb76-27"><a href="#cb76-27" aria-hidden="true" tabindex="-1"></a>put<span class="op">(</span><span class="kw">struct</span> kv_store <span class="op">*</span>store<span class="op">,</span> <span class="dt">unsigned</span> <span class="dt">long</span> key<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>value<span class="op">)</span></span>
<span id="cb76-28"><a href="#cb76-28" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb76-29"><a href="#cb76-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Allocate a structure on the stack! */</span></span>
<span id="cb76-30"><a href="#cb76-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> kv_entry ent <span class="op">=</span> <span class="op">{</span></span>
<span id="cb76-31"><a href="#cb76-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>key <span class="op">=</span> key<span class="op">,</span></span>
<span id="cb76-32"><a href="#cb76-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>value <span class="op">=</span> value</span>
<span id="cb76-33"><a href="#cb76-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb76-34"><a href="#cb76-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> kv_entry <span class="op">*</span>new_ent<span class="op">;</span></span>
<span id="cb76-35"><a href="#cb76-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Should check if the kv_store has open entries. */</span></span>
<span id="cb76-36"><a href="#cb76-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-37"><a href="#cb76-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Notice we have to pass the `&amp;ent` as a pointer is expected */</span></span>
<span id="cb76-38"><a href="#cb76-38" aria-hidden="true" tabindex="-1"></a>    new_ent <span class="op">=</span> lsearch<span class="op">(&amp;</span>ent<span class="op">,</span> store<span class="op">-&gt;</span>entries<span class="op">,</span> <span class="op">&amp;</span>store<span class="op">-&gt;</span>num_entries<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> kv_entry<span class="op">),</span> kv_comp<span class="op">);</span></span>
<span id="cb76-39"><a href="#cb76-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Should check if we found an old entry, and we need to update its value. */</span></span>
<span id="cb76-40"><a href="#cb76-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-41"><a href="#cb76-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>new_ent <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb76-42"><a href="#cb76-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-43"><a href="#cb76-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-44"><a href="#cb76-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-45"><a href="#cb76-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-46"><a href="#cb76-46" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb76-47"><a href="#cb76-47" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb76-48"><a href="#cb76-48" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb76-49"><a href="#cb76-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Allocated the data-store on the stack, including the array! */</span></span>
<span id="cb76-50"><a href="#cb76-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> kv_store store <span class="op">=</span> <span class="op">{</span> <span class="op">.</span>num_entries <span class="op">=</span> <span class="dv">0</span> <span class="op">};</span></span>
<span id="cb76-51"><a href="#cb76-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-52"><a href="#cb76-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">long</span> key <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb76-53"><a href="#cb76-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>value <span class="op">=</span> <span class="st">&quot;secret to everything&quot;</span><span class="op">;</span></span>
<span id="cb76-54"><a href="#cb76-54" aria-hidden="true" tabindex="-1"></a>    put<span class="op">(&amp;</span>store<span class="op">,</span> key<span class="op">,</span> value<span class="op">);</span></span>
<span id="cb76-55"><a href="#cb76-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-56"><a href="#cb76-56" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Validate that the store got modified in the appropriate way */</span></span>
<span id="cb76-57"><a href="#cb76-57" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>store<span class="op">.</span>num_entries <span class="op">==</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb76-58"><a href="#cb76-58" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>store<span class="op">.</span>entries<span class="op">[</span><span class="dv">0</span><span class="op">].</span>key <span class="op">==</span> key<span class="op">);</span></span>
<span id="cb76-59"><a href="#cb76-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-60"><a href="#cb76-60" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%ld</span><span class="st"> is the </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> store<span class="op">.</span>entries<span class="op">[</span><span class="dv">0</span><span class="op">].</span>key<span class="op">,</span> store<span class="op">.</span>entries<span class="op">[</span><span class="dv">0</span><span class="op">].</span>value<span class="op">);</span></span>
<span id="cb76-61"><a href="#cb76-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-62"><a href="#cb76-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb76-63"><a href="#cb76-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>In this program you might notice that we’ve used <em>no
            dynamic memory allocation at all</em>! The cost of this is
            that we had to create a key-value store of only a fixed size
            (<code>16</code> items, here).</p>
            <h3 data-number="4.1.6" id="comparing-c-to-java"><span
            class="header-section-number">4.1.6</span> Comparing C to
            Java</h3>
            <p>C enables a high-degree of control in which memory
            different variables should be placed. Java traditionally has
            simple rules for which memory is used for variables:</p>
            <ul>
            <li><em><a
            href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive
            types</a></em> are stored in objects and on the stack.</li>
            <li><em>Objects</em> are always allocated using
            <code>new</code> in the heap, and references to objects are
            always pointers.</li>
            <li>The heap is managed by the garbage collector, thus
            avoiding the need for <code>free</code>.</li>
            </ul>
            <p>Many aspects of this are absolutely fantastic:</p>
            <ul>
            <li>The programmer doesn’t need to think about how long the
            memory for an object needs to stick around – the garbage
            collector instead manages deallocation.</li>
            <li>The syntax for accessing fields in objects is uniform
            and simple: always use a <code>.</code> to access a field
            (e.g. <code>obj.a</code>) – all object references are
            pointers, so instead of having <code>-&gt;</code>
            everywhere, just replace it with the uniform
            <code>.</code>.</li>
            </ul>
            <p>However, there are significant downsides when the goal is
            to write systems code:</p>
            <ul>
            <li>Some systems don’t have a heap! Many embedded (small)
            systems don’t support dynamic allocation.</li>
            <li>Garbage collection (GC) isn’t free! It has some overhead
            for some applications, can result in larger memory
            consumption (as garbage is waiting to be collected), and can
            causes delays in processing when GC happens. That said,
            modern GC is pretty amazing and does a pretty good job at
            minimizing all of these factors.</li>
            <li>Many data-structures that might be allocated globally or
            on the stack, instead must be allocated on the heap, which
            is slower. Similarly, many objects might want other objects
            to be part of their allocation, but that isn’t possible as
            each must be a separate heap allocation, which adds
            overhead.</li>
            </ul>
            <h2 data-number="4.2" id="strings"><span
            class="header-section-number">4.2</span> Strings</h2>
            <p>String don’t have a dedicated type in C – there is no
            <code>String</code> type. Strings are</p>
            <ol type="1">
            <li>arrays of <code>char</code>s,</li>
            <li>with a null-terminator (<code>\0</code>) character in
            the last array position to denote the termination of the
            string.</li>
            </ol>
            <p>In memory, a simple string has this representation:</p>
            <pre><code>char *str = &quot;hi!&quot;

str ---&gt; +---+---+---+---+
         | h | i | ! |\0 |
         +---+---+---+---+</code></pre>
            <p>Note that <code>\0</code> is a single character even
            though it looks like two. We can see this:</p>
            <div class="sourceCode" id="cb78"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>str <span class="op">=</span> <span class="st">&quot;hi!&quot;</span><span class="op">;</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> str2<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;h&#39;</span><span class="op">,</span> <span class="ch">&#39;i&#39;</span><span class="op">,</span> <span class="ch">&#39;!&#39;</span><span class="op">,</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">};</span>        <span class="co">/* We can allocate strings on the stack! */</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> str<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>           <span class="co">/* Loop till we find the null-terminator */</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>        assert<span class="op">(</span>str<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> str2<span class="op">[</span>i<span class="op">]);</span>               <span class="co">/* Verify the strings are the same. */</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span><span class="op">,</span> str<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>str<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">==</span> str2<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">&amp;&amp;</span> str<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">);</span> <span class="co">/* Explicitly check that the null-terminator is there */</span></span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>So strings aren’t really all that special in C. They’re
            just arrays with a special terminating character, and a
            little bit of syntax support to construct them
            (i.e. <code>"this syntax"</code>). So what’s there to know
            about strings in C?</p>
            <h3 data-number="4.2.1" id="string.h-functions"><span
            class="header-section-number">4.2.1</span>
            <code>string.h</code> Functions</h3>
            <p>Working with strings is <em>not</em> C’s strong point.
            However, you have to handle strings in every language, and C
            provides a number of functions to do so. You can read about
            each of these <code>function</code>s with
            <code>man 3 &lt;function&gt;</code>.</p>
            <h4 data-number="4.2.1.1" id="core-string-operations"><span
            class="header-section-number">4.2.1.1</span> Core String
            Operations</h4>
            <ul>
            <li><code>strlen</code> - How many characters is a string
            (not including the null-terminator)?</li>
            <li><code>strcmp</code> - Compare two strings, return
            <code>0</code> if they are the same, or <code>-1</code> or
            <code>1</code>, depending on which is <a
            href="https://en.wikipedia.org/wiki/Lexicographic_order">lexographically
            less than the other</a>. Similar in purpose to
            <code>equals</code> in Java.</li>
            <li><code>strcpy</code> - Copy into a string the contents of
            another string.</li>
            <li><code>strcat</code> - Concatenate, or append onto the
            end of a string, another string.</li>
            <li><code>strdup</code> - Duplicate a string by
            <code>malloc</code>ing a new string, and copying the string
            into it (you have to <code>free</code> the string
            later!).</li>
            <li><code>snprintf</code> - You’re familiar with
            <code>printf</code>, but <code>snprintf</code> enables you
            to “print” into a string! This gives you a lot of
            flexibility in easily constructing strings. A downside is
            that you don’t really know how big the resulting string is,
            so the <code>n</code> in the name is the maximum length of
            the string you’re creating.</li>
            </ul>
            <div class="sourceCode" id="cb79"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> result<span class="op">[</span><span class="dv">256</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">,</span> <span class="op">};</span>                <span class="co">/* initialize string to be &quot;&quot; */</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>a <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="op">*</span>b <span class="op">=</span> <span class="st">&quot;world&quot;</span><span class="op">;</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ret<span class="op">;</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>strcmp<span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">);</span>                  <span class="co">/* these strings are different */</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>    strcat<span class="op">(</span>result<span class="op">,</span> a<span class="op">);</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>    strcat<span class="op">(</span>result<span class="op">,</span> <span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    strcat<span class="op">(</span>result<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>strcmp<span class="op">(</span>result<span class="op">,</span> <span class="st">&quot;hello world&quot;</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span> <span class="co">/* should have constructed this string properly */</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> strdup<span class="op">(</span>result<span class="op">);</span></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>strcmp<span class="op">(</span>d<span class="op">,</span> result<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span>             <span class="co">/* a duplicate should be equal */</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>d<span class="op">);</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-26"><a href="#cb79-26" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span>result<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span>                         <span class="co">/* reset the `result` to an empty string */</span></span>
<span id="cb79-27"><a href="#cb79-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-28"><a href="#cb79-28" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> snprintf<span class="op">(</span>result<span class="op">,</span> <span class="dv">255</span><span class="op">,</span> <span class="st">&quot;</span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st"> and also </span><span class="sc">%d</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb79-29"><a href="#cb79-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\&quot;%s\&quot;</span><span class="st"> has length </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> result<span class="op">,</span> ret<span class="op">);</span></span>
<span id="cb79-30"><a href="#cb79-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>Many of these functions raise an important question: What
            happens if one of the strings is not large enough to hold
            the data being put into it? If you want to
            <code>strcat</code> a long string into a small character
            array, what happens? This leads us to a simple fact…</p>
            <p><strong>It is <em>easy</em> to use the string functions
            incorrectly.</strong> Many of these functions also have a
            <code>strnX</code> variant where <code>X</code> is the
            operation (<code>strnlen</code>, <code>strncmp</code>,
            etc..). These are safer variants of the string functions.
            The key insight here is that if a string is derived from a
            user, it might not actually be a proper string! It might
            not, for example, have a null-terminator – uh oh! In that
            case, many of the above functions will keep on iterating
            <em>past</em> the end of the buffer</p>
            <div class="sourceCode" id="cb80"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> usr_str<span class="op">[</span><span class="dv">8</span><span class="op">];</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> my_str<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a><span class="co">     * This use of `strcpy` isn&#39;t bugged as we know the explicit string is 7 zs,</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="co">     * and 1 null-terminator, which can fit in `usr_str`.</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span>usr_str<span class="op">,</span> <span class="st">&quot;zzzzzzz&quot;</span><span class="op">);</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a><span class="co">     * Also fine: lets limit the copy to 3 bytes, then add a null-terminator ourself</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a><span class="co">     * (`strlcpy` would do this for us)</span></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>    strncpy<span class="op">(</span>my_str<span class="op">,</span> usr_str<span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>    my_str<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\0</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> my_str<span class="op">);</span></span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>    fflush<span class="op">(</span>stdout<span class="op">);</span>  <span class="co">/* don&#39;t mind me, making sure that your print outs happen */</span></span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a><span class="co">     * However, note that `strlen(usr_str)` is larger than the size of `my_str` (4),</span></span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a><span class="co">     * so we copy *past* the buffer size of `my_str`. This is called a &quot;buffer overflow&quot;.</span></span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true" tabindex="-1"></a>    strcpy<span class="op">(</span>my_str<span class="op">,</span> usr_str<span class="op">);</span></span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-33"><a href="#cb80-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb80-34"><a href="#cb80-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <h4 data-number="4.2.1.2" id="parsing-strings"><span
            class="header-section-number">4.2.1.2</span> Parsing
            Strings</h4>
            <p>While many of the previous functions have to do with
            creating and modifying strings, computers frequently need to
            “parse”, or try to understand the different parts of, a
            string. Some examples:</p>
            <ul>
            <li>The code we write in <code>.c</code> or
            <code>.java</code> files is just a long string, and the
            programming language needs to <em>parse</em> the string to
            understand what commands you’re trying to issue to the
            computer.</li>
            <li>The shell must <em>parse</em> your commands to determine
            which actions to perform.</li>
            <li>Webpages are simply a collection of <code>html</code>
            code (along with other assets), and a browser needs to
            <em>parse</em> it to determine what to display.</li>
            <li>The markdown text for this lecture is <em>parsed</em> by
            <code>pandoc</code> to generate a <code>pdf</code> and
            <code>html</code>.</li>
            </ul>
            <p>Some of the core functions that help us parse strings
            include:</p>
            <ul>
            <li><code>strtol</code> - Pull an integer out of a string.
            Converts the first part of a string into a
            <code>long int</code>, and also returns an
            <code>endptr</code> which points to the character
            <em>in</em> the string where the conversion into a number
            stopped. If it cannot find an integer, it will return
            <code>0</code>, and <code>endptr</code> is set to point to
            the start of the string.</li>
            <li><code>strtok</code> - Iterate through a string, and find
            the first instance of one of a number of specific
            characters, and return the string leading up to that
            character. This is called multiple times to iterate through
            the string, each time extracting the substring up to the
            specific characters. See the example in the <code>man</code>
            page for <code>strtok</code> for an example.</li>
            <li><code>strstr</code> - Try and find a string (the
            “needle”) in another string (the “haystack”), and return a
            pointer to it (or <code>NULL</code> if you don’t find it).
            As such, it finds a string in another string (thus
            <code>strstr</code>).</li>
            <li><code>sscanf</code> - A versatile function will enables
            a format string (e.g. as used in <code>printf</code>) to
            specify the format of the string, and extract out digits and
            substrings.</li>
            </ul>
            <p>Some examples:</p>
            <div class="sourceCode" id="cb81"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>input <span class="op">=</span> <span class="st">&quot;1 42 the secret to everything&quot;</span><span class="op">;</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>inputdup<span class="op">;</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>substr<span class="op">;</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>substr_saved<span class="op">;</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">int</span> extracted<span class="op">;</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> sec<span class="op">[</span><span class="dv">32</span><span class="op">];</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-16"><a href="#cb81-16" aria-hidden="true" tabindex="-1"></a>    extracted <span class="op">=</span> strtol<span class="op">(</span>input<span class="op">,</span> <span class="op">&amp;</span>substr<span class="op">,</span> <span class="dv">10</span><span class="op">);</span>                               <span class="co">/* pull out the first two integers */</span></span>
<span id="cb81-17"><a href="#cb81-17" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;extracted </span><span class="sc">%ld</span><span class="st">, remaining string: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> extracted<span class="op">,</span> substr<span class="op">);</span></span>
<span id="cb81-18"><a href="#cb81-18" aria-hidden="true" tabindex="-1"></a>    extracted <span class="op">=</span> strtol<span class="op">(</span>substr<span class="op">,</span> <span class="op">&amp;</span>substr<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb81-19"><a href="#cb81-19" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;extracted </span><span class="sc">%ld</span><span class="st">, remaining string: </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> extracted<span class="op">,</span> substr<span class="op">);</span></span>
<span id="cb81-20"><a href="#cb81-20" aria-hidden="true" tabindex="-1"></a>    substr_saved <span class="op">=</span> substr<span class="op">;</span></span>
<span id="cb81-21"><a href="#cb81-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-22"><a href="#cb81-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* what happens when we cannot extract a long? */</span></span>
<span id="cb81-23"><a href="#cb81-23" aria-hidden="true" tabindex="-1"></a>    extracted <span class="op">=</span> strtol<span class="op">(</span>substr_saved<span class="op">,</span> <span class="op">&amp;</span>substr<span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb81-24"><a href="#cb81-24" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>extracted <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> substr_saved <span class="op">==</span> substr<span class="op">);</span>                     <span class="co">/* verify that we couldn&#39;t extract an integer */</span></span>
<span id="cb81-25"><a href="#cb81-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-26"><a href="#cb81-26" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>strcmp<span class="op">(</span>strstr<span class="op">(</span>input<span class="op">,</span> <span class="st">&quot;secret&quot;</span><span class="op">),</span> <span class="st">&quot;secret to everything&quot;</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span> <span class="co">/* find secret substring */</span></span>
<span id="cb81-27"><a href="#cb81-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-28"><a href="#cb81-28" aria-hidden="true" tabindex="-1"></a>    sscanf<span class="op">(</span>input<span class="op">,</span> <span class="st">&quot;1 </span><span class="sc">%ld</span><span class="st"> the </span><span class="sc">%s</span><span class="st"> to everything&quot;</span><span class="op">,</span> <span class="op">&amp;</span>extracted<span class="op">,</span> sec<span class="op">);</span>         <span class="co">/* extract out the number and the secret */</span></span>
<span id="cb81-29"><a href="#cb81-29" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%ld</span><span class="st"> and </span><span class="sc">\&quot;%s\&quot;\n</span><span class="st">&quot;</span><span class="op">,</span> extracted<span class="op">,</span> sec<span class="op">);</span></span>
<span id="cb81-30"><a href="#cb81-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-31"><a href="#cb81-31" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Using strtok to parse through a string finding substrings separated by &#39;h&#39; or &#39;t&#39;:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb81-32"><a href="#cb81-32" aria-hidden="true" tabindex="-1"></a>    inputdup <span class="op">=</span> strdup<span class="op">(</span>input<span class="op">);</span>                                            <span class="co">/* strtok will modify the string, lets copy it */</span></span>
<span id="cb81-33"><a href="#cb81-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>substr <span class="op">=</span> strtok<span class="op">(</span>inputdup<span class="op">,</span> <span class="st">&quot;ht&quot;</span><span class="op">);</span> substr <span class="op">!=</span> NULL<span class="op">;</span> substr <span class="op">=</span> strtok<span class="op">(</span>NULL<span class="op">,</span> <span class="st">&quot;ht&quot;</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb81-34"><a href="#cb81-34" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;[</span><span class="sc">%s</span><span class="st">]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> substr<span class="op">);</span></span>
<span id="cb81-35"><a href="#cb81-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb81-36"><a href="#cb81-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-37"><a href="#cb81-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb81-38"><a href="#cb81-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <h3 data-number="4.2.2" id="bonus-explicit-strings"><span
            class="header-section-number">4.2.2</span> Bonus: Explicit
            Strings</h3>
            <p>When you use an explicit string
            (e.g. <code>"imma string"</code>) in your code, you’re
            actually asking C to allocate the string in global memory.
            This has some strange side-effects:</p>
            <div class="sourceCode" id="cb82"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> c<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>a <span class="op">=</span> <span class="st">&quot;blah&quot;</span><span class="op">;</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>b <span class="op">=</span> <span class="st">&quot;blah&quot;</span><span class="op">;</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>    strncpy<span class="op">(</span>c<span class="op">,</span> a<span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%s%s%s\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* compare the three pointers */</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%p</span><span class="st"> == </span><span class="sc">%p</span><span class="st"> != </span><span class="sc">%p\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>The C compiler and linker are smart enough to see that if
            you have already used a string with a specific value (in
            this case <code>"clone"</code>), it will avoid allocating a
            copy of that string, and will just reuse the previous value.
            Generally, it doesn’t make much sense to look at the address
            of strings, and certainly you should not compare them. You
            can see in this example how you must compare strings for
            equality using <code>strncmp</code>, and <em>not</em> to
            compare pointers.</p>
            <h2 data-number="4.3" id="api-design-and-concerns"><span
            class="header-section-number">4.3</span> API Design and
            Concerns</h2>
            <p><a
            href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/api_design.html#/">Slides</a></p>
            <p>When programming in C, you’ll see quite a few APIs.
            Throughout the class, we’ll see quite a few APIs, most
            documented in <code>man</code> pages. It takes some practice
            in reading <code>man</code> pages to get what you need from
            them. One of the things that helps the most is to understand
            a few common <em>patterns</em> and <em>requirements</em>
            that you find these APIs, and in C programming in
            general.</p>
            <h3 data-number="4.3.1" id="return-values"><span
            class="header-section-number">4.3.1</span> Return
            Values</h3>
            <p>Functions often need to return multiple values. C does
            not provide a means to return more than one value, thus is
            forced to use pointers. To understand this, lets look at the
            multiple ways that pointers can be used as function
            arguments.</p>
            <div class="sourceCode" id="cb83"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * `arg` is used to pass an argument that happens to be an array here. In contrast,</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * `ret` is a *second return value*. This function will set the value that `ret` points</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * to -- which happens to be `retval` in the `main` stack frame -- to the value we are</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * getting from the array.</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>get<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>arg<span class="op">,</span> <span class="dt">int</span> offset<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>ret<span class="op">)</span></span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>arg <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ret <span class="op">=</span> arg<span class="op">[</span>offset<span class="op">];</span></span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a><span class="co"> * Again, the array is passed in as the first argument, but this time it is used to</span></span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a><span class="co"> * store the new value.</span></span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a>set<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>ret_val<span class="op">,</span> <span class="dt">int</span> offset<span class="op">,</span> <span class="dt">int</span> value<span class="op">)</span></span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ret_val <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a>    ret_val<span class="op">[</span>offset<span class="op">]</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a><span class="co"> * `arrdup`&#39;s job is to duplicate an array by allocating and populating</span></span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a><span class="co"> * a new array. It will return `0` or not `0` on success/failure. Thus</span></span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * the new array must be returned using pointer arguments. `ret_allocated`</span></span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a><span class="co"> * is a pointer to a pointer to an array in the calling function, and it</span></span>
<span id="cb83-40"><a href="#cb83-40" aria-hidden="true" tabindex="-1"></a><span class="co"> * is used to return the new array.</span></span>
<span id="cb83-41"><a href="#cb83-41" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb83-42"><a href="#cb83-42" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb83-43"><a href="#cb83-43" aria-hidden="true" tabindex="-1"></a>arrdup<span class="op">(</span><span class="dt">int</span> <span class="op">**</span>ret_allocated<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>args<span class="op">,</span> <span class="dt">size_t</span> args_size<span class="op">)</span></span>
<span id="cb83-44"><a href="#cb83-44" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb83-45"><a href="#cb83-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> i<span class="op">;</span></span>
<span id="cb83-46"><a href="#cb83-46" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>newarr<span class="op">;</span></span>
<span id="cb83-47"><a href="#cb83-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-48"><a href="#cb83-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ret_allocated <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-49"><a href="#cb83-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-50"><a href="#cb83-50" aria-hidden="true" tabindex="-1"></a>    newarr <span class="op">=</span> calloc<span class="op">(</span>args_size<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span> <span class="co">/* 1 below */</span></span>
<span id="cb83-51"><a href="#cb83-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>newarr <span class="op">==</span> NULL<span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb83-52"><a href="#cb83-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-53"><a href="#cb83-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> args_size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb83-54"><a href="#cb83-54" aria-hidden="true" tabindex="-1"></a>        newarr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> args<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb83-55"><a href="#cb83-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb83-56"><a href="#cb83-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>ret_allocated <span class="op">=</span> newarr<span class="op">;</span> <span class="co">/* 2 and 3 below */</span></span>
<span id="cb83-57"><a href="#cb83-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-58"><a href="#cb83-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-59"><a href="#cb83-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb83-60"><a href="#cb83-60" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb83-61"><a href="#cb83-61" aria-hidden="true" tabindex="-1"></a><span class="co"> * Lets draw this one. The stack setup when we call `arrdup`:</span></span>
<span id="cb83-62"><a href="#cb83-62" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-63"><a href="#cb83-63" aria-hidden="true" tabindex="-1"></a><span class="co"> * |               |</span></span>
<span id="cb83-64"><a href="#cb83-64" aria-hidden="true" tabindex="-1"></a><span class="co"> * +-main----------+</span></span>
<span id="cb83-65"><a href="#cb83-65" aria-hidden="true" tabindex="-1"></a><span class="co"> * | arr           |&lt;---+</span></span>
<span id="cb83-66"><a href="#cb83-66" aria-hidden="true" tabindex="-1"></a><span class="co"> * | dup           |&lt;-+ |</span></span>
<span id="cb83-67"><a href="#cb83-67" aria-hidden="true" tabindex="-1"></a><span class="co"> * | ...           |  | |</span></span>
<span id="cb83-68"><a href="#cb83-68" aria-hidden="true" tabindex="-1"></a><span class="co"> * +-arrdup--------+  | |</span></span>
<span id="cb83-69"><a href="#cb83-69" aria-hidden="true" tabindex="-1"></a><span class="co"> * | ret_allocated |--+ |</span></span>
<span id="cb83-70"><a href="#cb83-70" aria-hidden="true" tabindex="-1"></a><span class="co"> * | args          |----+</span></span>
<span id="cb83-71"><a href="#cb83-71" aria-hidden="true" tabindex="-1"></a><span class="co"> * | ...           |</span></span>
<span id="cb83-72"><a href="#cb83-72" aria-hidden="true" tabindex="-1"></a><span class="co"> * +---------------+</span></span>
<span id="cb83-73"><a href="#cb83-73" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-74"><a href="#cb83-74" aria-hidden="true" tabindex="-1"></a><span class="co"> * `ret_allocated` points to `dup` in `main`.</span></span>
<span id="cb83-75"><a href="#cb83-75" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-76"><a href="#cb83-76" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-77"><a href="#cb83-77" aria-hidden="true" tabindex="-1"></a><span class="co"> *    3. *ret_allocated = newarr</span></span>
<span id="cb83-78"><a href="#cb83-78" aria-hidden="true" tabindex="-1"></a><span class="co"> *                          ^</span></span>
<span id="cb83-79"><a href="#cb83-79" aria-hidden="true" tabindex="-1"></a><span class="co"> *                          |</span></span>
<span id="cb83-80"><a href="#cb83-80" aria-hidden="true" tabindex="-1"></a><span class="co"> *            ,-------------&#39;</span></span>
<span id="cb83-81"><a href="#cb83-81" aria-hidden="true" tabindex="-1"></a><span class="co"> *           |</span></span>
<span id="cb83-82"><a href="#cb83-82" aria-hidden="true" tabindex="-1"></a><span class="co"> * |         |     |</span></span>
<span id="cb83-83"><a href="#cb83-83" aria-hidden="true" tabindex="-1"></a><span class="co"> * +-main----|-----+</span></span>
<span id="cb83-84"><a href="#cb83-84" aria-hidden="true" tabindex="-1"></a><span class="co"> * | arr     |     |</span></span>
<span id="cb83-85"><a href="#cb83-85" aria-hidden="true" tabindex="-1"></a><span class="co"> * | dup ---&#39;  &lt;------+</span></span>
<span id="cb83-86"><a href="#cb83-86" aria-hidden="true" tabindex="-1"></a><span class="co"> * | ...           |  | -- 2. *ret_allocated</span></span>
<span id="cb83-87"><a href="#cb83-87" aria-hidden="true" tabindex="-1"></a><span class="co"> * +-arrdup--------+  |</span></span>
<span id="cb83-88"><a href="#cb83-88" aria-hidden="true" tabindex="-1"></a><span class="co"> * | ret_allocated ---+</span></span>
<span id="cb83-89"><a href="#cb83-89" aria-hidden="true" tabindex="-1"></a><span class="co"> * | args          |</span></span>
<span id="cb83-90"><a href="#cb83-90" aria-hidden="true" tabindex="-1"></a><span class="co"> * | newarr --------------&gt; 1. calloc(...)</span></span>
<span id="cb83-91"><a href="#cb83-91" aria-hidden="true" tabindex="-1"></a><span class="co"> * +---------------+</span></span>
<span id="cb83-92"><a href="#cb83-92" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-93"><a href="#cb83-93" aria-hidden="true" tabindex="-1"></a><span class="co"> * 1. `arrdup` calls `calloc` to allocate on the heap</span></span>
<span id="cb83-94"><a href="#cb83-94" aria-hidden="true" tabindex="-1"></a><span class="co"> * 2. Dereferencing `ret_allocated` gives us access to `dup`</span></span>
<span id="cb83-95"><a href="#cb83-95" aria-hidden="true" tabindex="-1"></a><span class="co"> * 3. thus we can set dup equal to the new heap memory</span></span>
<span id="cb83-96"><a href="#cb83-96" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb83-97"><a href="#cb83-97" aria-hidden="true" tabindex="-1"></a><span class="co"> * This effectively enables us to return the new memory into the</span></span>
<span id="cb83-98"><a href="#cb83-98" aria-hidden="true" tabindex="-1"></a><span class="co"> * `dup` variable in main.</span></span>
<span id="cb83-99"><a href="#cb83-99" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb83-100"><a href="#cb83-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-101"><a href="#cb83-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-102"><a href="#cb83-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-103"><a href="#cb83-103" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb83-104"><a href="#cb83-104" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb83-105"><a href="#cb83-105" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb83-106"><a href="#cb83-106" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> arr<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb83-107"><a href="#cb83-107" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>dup<span class="op">;</span></span>
<span id="cb83-108"><a href="#cb83-108" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> retval<span class="op">;</span></span>
<span id="cb83-109"><a href="#cb83-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-110"><a href="#cb83-110" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>get<span class="op">(</span>arr<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">&amp;</span>retval<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> retval <span class="op">==</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb83-111"><a href="#cb83-111" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>set<span class="op">(</span>arr<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb83-112"><a href="#cb83-112" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>get<span class="op">(</span>arr<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">&amp;</span>retval<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> retval <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb83-113"><a href="#cb83-113" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>arrdup<span class="op">(&amp;</span>dup<span class="op">,</span> arr<span class="op">,</span> <span class="dv">4</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb83-114"><a href="#cb83-114" aria-hidden="true" tabindex="-1"></a>    assert<span class="op">(</span>get<span class="op">(</span>dup<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">&amp;</span>retval<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> retval <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb83-115"><a href="#cb83-115" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>dup<span class="op">);</span></span>
<span id="cb83-116"><a href="#cb83-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-117"><a href="#cb83-117" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;no errors!&quot;</span><span class="op">);</span></span>
<span id="cb83-118"><a href="#cb83-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-119"><a href="#cb83-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-120"><a href="#cb83-120" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <!-- COMBINED ERROR NOTES WITH NEW MATERIAL IN ANOTHER FILE BY SIBIN in OCT 2023!

            ### Errors

            The first question is how we can detect that some error occurred within a function we have called?
            We'll separate functions into two different classes:

            1. *Functions that return pointers.*
                Functions that return pointers (e.g. that have declarations of the form `type *fn(...)`) are often relatively straightforward.
                If they return `NULL`, then an error occurred; otherwise the returned pointer can be used.
                `malloc` is an example here.
            2. *Functions that return integers.*
                Integers are used as a relatively flexible indication of the output of a function.
                Is it common for a `-1` to indicate an error.
                Sometimes *any* negative value indicates an error, each negative value designating that a different error occurred.
                Non-negative values indicate success.
                If a function wishes to return a binary success or failure, you'll see that many APIs (counter-intuitively) return `0` for success, and `-1` for failure.

            It is common that you want more information than the return value can give you.
            You want more information about *why* the failure happened so that you can debug more easily.
            The `errno` variable is UNIX's solution to this (see its `man` page), and can be referenced if you include `errno.h`.
            `errno` is simply an integer where specific values represent specific errors.
            You can view these values by looking them up in the source^[For example, in `/usr/include/asm/errno.h`.] or, you can ask the `errno` *program*^[You might need to do `apt-get install moreutils` if you're using your own system.].
            For example:

            ```
            $ errno -l
            EPERM 1 Operation not permitted
            ENOENT 2 No such file or directory
            ESRCH 3 No such process
            EINTR 4 Interrupted system call
            EIO 5 Input/output error
            ...
            ```

            You can look up specific values:

            ```
            $ errno 28
            ENOSPC 28 No space left on device
            ```

            You can imagine how that error might occur.
            What if you're trying to add files on disk, and the disk runs out of room!?

            If you want your program to print a useful error when you encounter such a problem, you can use the `perror` function (see its `man` page for documentation) to print out an error, or `strerror` (via `string.h`) if you just want a string corresponding to the error.

            ```c
            #include <stdlib.h>
            #include <limits.h>
            #include <stdio.h>
            #include <errno.h>
            #include <string.h>

            int
            main(void)
            {
                char *ret;

                printf("Lets get greedy: allocate %ld bytes!\n", LONG_MAX);
                ret = malloc(LONG_MAX);
                if (ret == NULL) {
                    printf("Error: errno value %d and description: %s\n", errno, strerror(errno));
                    fflush(stdout);
                    perror("Error allocating memory");

                    return -1;
                }

                return 0;
            }
            ```

            (Note: when you return from a program with a non-zero value, it designates that your *program* had an error.
            This is why we see the `make` error when it runs your program.)

            To understand the return value of UNIX library functions:

            - look at the function return values to understand the type (and identify if it is returning an `int` or a pointer)
            ```
            SYNOPSIS
                   #include <stdlib.h>

                   void *malloc(size_t size);
                   ...
            ```
            - Read through the description of the function(s).
            - Read through the `RETURN VALUE` and `ERRORS` sections of the man page.
            ```
            RETURN VALUE
                   The malloc() and calloc() functions return a pointer to the allocated memory, which is  suitably  aligned  for
                   any  built-in type.  On error, these functions return NULL.  NULL may also be returned by a successful call to
                   malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.
            ...
            ERRORS
                   calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

                   ENOMEM Out  of  memory.
                   ...

            ```

            This explains why we got the error we did.
            -->
            <h3 data-number="4.3.2" id="memory-ownership"><span
            class="header-section-number">4.3.2</span> Memory
            Ownership</h3>
            <p>One of the last, but most challenging aspects of APIs in
            C is that of memory ownership. The big question is: when a
            pointer passed into a function, or returned from a function,
            who is responsible for <code>free</code>ing the memory? This
            is due to a combination of factors, mainly:</p>
            <ol type="1">
            <li>C requires that memory is explicitly <code>free</code>d,
            so someone has to do it, and it should be <code>free</code>d
            <em>only once</em>, and</li>
            <li>pointers are passed around freely and frequently in C,
            so somehow the function caller and callee have to understand
            who “owns” each of those pointers.</li>
            </ol>
            <p>It is easiest to understand this issue through the
            concept of <em>ownership</em>: simply put, the owner of a
            piece of memory is the one that should either free it, or
            pass it to another part of the code that becomes the owner.
            In contrast, a caller can pass a pointer to memory into a
            function allowing it to <em>borrow</em> that memory, but the
            function does <em>not</em> free it, and after it returns it
            should not further access the memory. There are three
            general patterns:</p>
            <ul>
            <li><p>A caller <em>passes a pointer</em> into a function,
            and <em>passes the ownership</em> of that data to the
            function. This is common for data-structures whose job is to
            take a pointer of data to store, and at that point, they own
            the memory. Think: if we <code>enqueue</code> data into a
            queue.</p>
            <p><strong>Examples</strong>: The key-value store’s
            <code>put</code> function owns the passed in data (assuming
            it takes a <code>void *</code>.</p></li>
            <li><p>A function <em>returns a pointer</em> to the function
            caller and <em>passes the ownership</em> to the caller. The
            caller must later <code>free</code> the data. This is also
            common in data-structures when we wish to retrieve the data.
            Think: if we <code>dequeue</code> data from a queue.</p>
            <p><strong>Examples</strong>: <code>strdup</code> creates a
            new string, expecting the caller to free it.</p></li>
            <li><p>A caller <em>passes a pointer</em> into a function,
            but only allows the function to <em>borrow</em> the data.
            Thus the caller still owns the memory (thus is still
            responsible to <code>free</code> the data) after the
            function returns, and the function should <em>not</em>
            maintain any references to the data. Think: most of the
            string functions that take a string as an argument, perform
            some operation on it, and return expecting the caller to
            still <code>free</code> the string.</p>
            <p><strong>Examples</strong>: Most other functions we’ve
            seen borrow pointers, perform operations, and then don’t
            maintain references to them.</p></li>
            <li><p>A function <em>returns a pointer</em> to the function
            caller that enables the caller to <em>borrow</em> the data.
            This requires a difficult constraint: the caller can access
            the data, but must not maintain a pointer to it after the
            function or API (that still owns the data)
            <code>free</code>s it.</p>
            <p><strong>Examples</strong>: The key-value store’s
            <code>get</code> function transfers ownership to the
            caller.</p></li>
            </ul>
            <p>The memory ownership constraints are an agreement between
            the calling function, and a function being called.</p>
            <h2 data-number="4.4" id="exercises-1"><span
            class="header-section-number">4.4</span> Exercises</h2>
            <h3 data-number="4.4.1" id="stack-allocation-1"><span
            class="header-section-number">4.4.1</span> Stack
            Allocation</h3>
            <p>An old interview question:</p>
            <blockquote>
            <p>How can you write a function that determines if the
            execution stack grows upwards (from lower addresses to
            higher), or downwards?</p>
            </blockquote>
            <p>Write this function!</p>
            <h3 data-number="4.4.2"
            id="understanding-memory-ownership"><span
            class="header-section-number">4.4.2</span> Understanding
            Memory Ownership</h3>
            <p>Lets look at a simple key-value store that needs to learn
            to be more careful about memory. Above each function, we
            specify the ownership of pointers being passed – either
            passing ownership, or borrowing the memory. The current
            implementations do <em>not</em> adhere to these
            specifications.</p>
            <div class="sourceCode" id="cb84"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="co"> * Lets just use a single key/value as a proxy for an entire kv/store.</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a><span class="co"> * You can assume that the stored values are strings, so `strdup` can</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * allocate the memory for and copy the values. You absolutely will</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * have to use `strdup` in some of the functions.</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span>   kv_key<span class="op">;</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">char</span> <span class="op">*</span>kv_value<span class="op">;</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="co"> * The returned value should not be maintained in the data-structure</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a><span class="co"> * and should be `free`d by the caller.</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>get_pass_ownership<span class="op">(</span><span class="dt">int</span> key<span class="op">)</span></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>key <span class="op">!=</span> kv_key<span class="op">)</span> <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kv_value<span class="op">;</span></span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a><span class="co"> * Pointers to the returned value are maintained in this data-structure</span></span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a><span class="co"> * and it will be `free`d by the data-structure, not by the caller</span></span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span></span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>get_borrow<span class="op">(</span><span class="dt">int</span> key<span class="op">)</span></span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>key <span class="op">!=</span> kv_key<span class="op">)</span> <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-34"><a href="#cb84-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kv_value<span class="op">;</span></span>
<span id="cb84-35"><a href="#cb84-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-36"><a href="#cb84-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-37"><a href="#cb84-37" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb84-38"><a href="#cb84-38" aria-hidden="true" tabindex="-1"></a><span class="co"> * Pointers to the `value` passed as the second argument are maintained by</span></span>
<span id="cb84-39"><a href="#cb84-39" aria-hidden="true" tabindex="-1"></a><span class="co"> * the caller, thus the `value` is borrowed here. The `value` will be `free`d</span></span>
<span id="cb84-40"><a href="#cb84-40" aria-hidden="true" tabindex="-1"></a><span class="co"> * by the caller.</span></span>
<span id="cb84-41"><a href="#cb84-41" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb84-42"><a href="#cb84-42" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb84-43"><a href="#cb84-43" aria-hidden="true" tabindex="-1"></a>set_borrow<span class="op">(</span><span class="dt">int</span> key<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>value<span class="op">)</span></span>
<span id="cb84-44"><a href="#cb84-44" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-45"><a href="#cb84-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* What do we do with `kv_value`? Do we `strdup` anything? */</span></span>
<span id="cb84-46"><a href="#cb84-46" aria-hidden="true" tabindex="-1"></a>    kv_key   <span class="op">=</span> key<span class="op">;</span></span>
<span id="cb84-47"><a href="#cb84-47" aria-hidden="true" tabindex="-1"></a>    kv_value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb84-48"><a href="#cb84-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-49"><a href="#cb84-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb84-50"><a href="#cb84-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-51"><a href="#cb84-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-52"><a href="#cb84-52" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb84-53"><a href="#cb84-53" aria-hidden="true" tabindex="-1"></a><span class="co"> * Pointers to the `value` passed as the second argument are not maintained by</span></span>
<span id="cb84-54"><a href="#cb84-54" aria-hidden="true" tabindex="-1"></a><span class="co"> * the caller, thus the `value` should be `free`d by this data-structure.</span></span>
<span id="cb84-55"><a href="#cb84-55" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb84-56"><a href="#cb84-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb84-57"><a href="#cb84-57" aria-hidden="true" tabindex="-1"></a>set_pass_ownership<span class="op">(</span><span class="dt">int</span> key<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>value<span class="op">)</span></span>
<span id="cb84-58"><a href="#cb84-58" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-59"><a href="#cb84-59" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* What do we do with `kv_value`? Do we `strdup` anything? */</span></span>
<span id="cb84-60"><a href="#cb84-60" aria-hidden="true" tabindex="-1"></a>    kv_key   <span class="op">=</span> key<span class="op">;</span></span>
<span id="cb84-61"><a href="#cb84-61" aria-hidden="true" tabindex="-1"></a>    kv_value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb84-62"><a href="#cb84-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-63"><a href="#cb84-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb84-64"><a href="#cb84-64" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-65"><a href="#cb84-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-66"><a href="#cb84-66" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb84-67"><a href="#cb84-67" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb84-68"><a href="#cb84-68" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb84-69"><a href="#cb84-69" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The values we pass in. */</span></span>
<span id="cb84-70"><a href="#cb84-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>v_p2p <span class="op">=</span> strdup<span class="op">(</span><span class="st">&quot;value1&quot;</span><span class="op">);</span> <span class="co">/* calls `malloc` ! */</span></span>
<span id="cb84-71"><a href="#cb84-71" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>v_p2b <span class="op">=</span> strdup<span class="op">(</span><span class="st">&quot;value2&quot;</span><span class="op">);</span></span>
<span id="cb84-72"><a href="#cb84-72" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>v_b2p <span class="op">=</span> strdup<span class="op">(</span><span class="st">&quot;value3&quot;</span><span class="op">);</span></span>
<span id="cb84-73"><a href="#cb84-73" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>v_b2b <span class="op">=</span> strdup<span class="op">(</span><span class="st">&quot;value4&quot;</span><span class="op">);</span></span>
<span id="cb84-74"><a href="#cb84-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-75"><a href="#cb84-75" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The return values */</span></span>
<span id="cb84-76"><a href="#cb84-76" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>r_p2p<span class="op">,</span> <span class="op">*</span>r_p2b<span class="op">,</span> <span class="op">*</span>r_b2p<span class="op">,</span> <span class="op">*</span>r_b2b<span class="op">;</span></span>
<span id="cb84-77"><a href="#cb84-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-78"><a href="#cb84-78" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* p2p: passing ownership on set, passing ownership on get */</span></span>
<span id="cb84-79"><a href="#cb84-79" aria-hidden="true" tabindex="-1"></a>    set_pass_ownership<span class="op">(</span><span class="dv">0</span><span class="op">,</span> v_p2p<span class="op">);</span></span>
<span id="cb84-80"><a href="#cb84-80" aria-hidden="true" tabindex="-1"></a>    r_p2p <span class="op">=</span> get_pass_ownership<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb84-81"><a href="#cb84-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The question: should we `free(v_p2p)`?, `free(r_p2p)`? */</span></span>
<span id="cb84-82"><a href="#cb84-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-83"><a href="#cb84-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* p2b: passing ownership on set, borrowing memory for get */</span></span>
<span id="cb84-84"><a href="#cb84-84" aria-hidden="true" tabindex="-1"></a>    set_pass_ownership<span class="op">(</span><span class="dv">0</span><span class="op">,</span> v_p2b<span class="op">);</span></span>
<span id="cb84-85"><a href="#cb84-85" aria-hidden="true" tabindex="-1"></a>    r_p2b <span class="op">=</span> get_borrow<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb84-86"><a href="#cb84-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The question: should we `free(v_p2b)`?, `free(r_p2b)`? */</span></span>
<span id="cb84-87"><a href="#cb84-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-88"><a href="#cb84-88" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* b2p: borrowing ownership on set, passing ownership on get */</span></span>
<span id="cb84-89"><a href="#cb84-89" aria-hidden="true" tabindex="-1"></a>    set_borrow<span class="op">(</span><span class="dv">0</span><span class="op">,</span> v_b2p<span class="op">);</span></span>
<span id="cb84-90"><a href="#cb84-90" aria-hidden="true" tabindex="-1"></a>    r_b2p <span class="op">=</span> get_pass_ownership<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb84-91"><a href="#cb84-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The question: should we `free(v_b2p)`?, `free(r_b2p)`? */</span></span>
<span id="cb84-92"><a href="#cb84-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-93"><a href="#cb84-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* b2b: borrowing ownership on set, borrowing on get */</span></span>
<span id="cb84-94"><a href="#cb84-94" aria-hidden="true" tabindex="-1"></a>    set_borrow<span class="op">(</span><span class="dv">0</span><span class="op">,</span> v_b2b<span class="op">);</span></span>
<span id="cb84-95"><a href="#cb84-95" aria-hidden="true" tabindex="-1"></a>    r_b2b <span class="op">=</span> get_borrow<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb84-96"><a href="#cb84-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* The question: should we `free(v_b2b)`?, `free(r_b2b)`? */</span></span>
<span id="cb84-97"><a href="#cb84-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-98"><a href="#cb84-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>kv_value<span class="op">)</span> free<span class="op">(</span>kv_value<span class="op">);</span></span>
<span id="cb84-99"><a href="#cb84-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-100"><a href="#cb84-100" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Looks like success!...but wait till we valgrind; then ;-(</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb84-101"><a href="#cb84-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-102"><a href="#cb84-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb84-103"><a href="#cb84-103" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p>The above code is hopelessly broken. Run it in valgrind
            to see.</p>
            <p><strong>Tasks:</strong></p>
            <ul>
            <li>In the above code, implement the
            <code>malloc</code>/<code>free</code>/<code>strdup</code>
            operations that are necessary both in the key-value
            implementation, and in the client (<code>main</code>) to
            make both the caller and callee abide by the memory
            ownership constraints.</li>
            <li>In which cases can <em>stack allocation</em> of the
            values be used in <code>main</code>? Why?</li>
            <li>In which cases can <em>stack allocation</em> of the
            values in the key-value store (i.e. in
            <code>get</code>/<code>set</code>) be used? Why?</li>
            </ul>
            <h2 data-number="4.5" id="errors"><span
            class="header-section-number">4.5</span> Errors</h2>
            <p><a
            href="https://sibin.github.io/teaching/csci2410-gwu-systems_programming/fall_2023/slides/reveal_slides/errors.html#/">Slides</a></p>
            <p>Sometimes, errors happen…</p>
            <ul>
            <li><em>e.g.,</em> system is out of memory</li>
            <li>when we call <sc>malloc</sc></li>
            </ul>
            <p>The first question is how we can detect that some error
            occurred within a function we have called?</p>
            <p><strong>When errors occur</strong></p>
            <ul>
            <li>we want more <strong>context</strong>
            <ul>
            <li>what was the <em>exact</em> error?</li>
            <li><em>where</em> did the error occur?</li>
            </ul></li>
            <li>programmers can make <em>informed</em> choices
            <ul>
            <li>on how to respond</li>
            </ul></li>
            </ul>
            <h3 data-number="4.5.1"
            id="return-vals-indicate-errors"><span
            class="header-section-number">4.5.1</span>
            <strong>return</strong> vals → indicate errors</h3>
            <table>
            <thead>
            <tr class="header">
            <th>functions return</th>
            <th>error indicator</th>
            <th>example</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td>integers</td>
            <td>negative values</td>
            <td><sc>printf()*</sc></td>
            </tr>
            <tr class="even">
            <td>pointers</td>
            <td><sc>NULL</sc></td>
            <td><sc>malloc()</sc></td>
            </tr>
            <tr class="odd">
            <td>structs</td>
            <td>fields in struct</td>
            <td>user defined</td>
            </tr>
            <tr class="even">
            <td></td>
            <td></td>
            <td></td>
            </tr>
            </tbody>
            </table>
            <p>[*check out the return value of
            <code>printf()</code>]</p>
            <p>As seen above, we separate functions into two different
            classes:</p>
            <ol type="1">
            <li><em>Functions that return pointers.</em> Functions that
            return pointers (e.g. that have declarations of the form
            <code>type *fn(...)</code>) are often relatively
            straightforward. If they return <code>NULL</code>, then an
            error occurred; otherwise the returned pointer can be used.
            <code>malloc</code> is an example here.</li>
            <li><em>Functions that return integers.</em> Integers are
            used as a relatively flexible indication of the output of a
            function. Is it common for a <code>-1</code> to indicate an
            error. Sometimes <em>any</em> negative value indicates an
            error, each negative value designating that a different
            error occurred. Non-negative values indicate success. If a
            function wishes to return a binary success or failure,
            you’ll see that many APIs (counter-intuitively) return
            <code>0</code> for success, and <code>-1</code> for
            failure.</li>
            </ol>
            <p>It is common that you want more information than a
            <em>single</em> return value can give you. So, we can define
            our own struct,</p>
            <div class="sourceCode" id="cb85"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ret_type<span class="op">{</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> carray <span class="op">;</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> error_number <span class="op">;</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> error_name<span class="op">[</span><span class="dv">255</span><span class="op">]</span> <span class="op">;</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="op">;</span></span></code></pre></div>
            <h3 data-number="4.5.2"
            id="errno-variable-and-command"><span
            class="header-section-number">4.5.2</span>
            <code>errno</code> variable and command</h3>
            <p>UNIX/C have some mechanisms that actually help (instead
            of defining our own structs). They define a
            <strong>variable</strong>, <code>errno</code>, defined in
            <code>&lt;error.h&gt;</code>.</p>
            <p><code>errno</code> is simply an integer where specific
            values represent specific errors. You can view these values
            by looking them up in the source<a href="#fn5"
            class="footnote-ref" id="fnref5"
            role="doc-noteref"><sup>5</sup></a>.</p>
            <p>Or, you can ask the <code>errno</code> <em>program</em>^
            (yes, the same name, confusing!), the command line utility
            (you might need to do <code>apt-get install moreutils</code>
            to get the <code>errno</code> program to work if you’re
            using your own system) used as follows:</p>
            <div class="sourceCode" id="cb86"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>$ errno <span class="dv">12</span> </span></code></pre></div>
            <p>Output:</p>
            <div class="sourceCode" id="cb87"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>ENOMEM <span class="dv">12</span> Cannot allocate memory</span></code></pre></div>
            <p>You can imagine why this error might occur – your system
            ran out of memory or you asked for too much!</p>
            <p>If we want to see a <strong>full</strong> list of all
            possible <code>errno</code> values and their meanings, we
            do:</p>
            <div class="sourceCode" id="cb88"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>$ errno <span class="op">-</span>l</span></code></pre></div>
            <p>Output (prints <strong>all</strong> of the error numbers
            and codes):</p>
            <div class="sourceCode" id="cb89"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>EPERM <span class="dv">1</span> Operation not permitted</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>ENOENT <span class="dv">2</span> No such file or directory</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>ESRCH <span class="dv">3</span> No such process</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>EINTR <span class="dv">4</span> Interrupted system call</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>EIO <span class="dv">5</span> Input<span class="op">/</span>output error</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>ENXIO <span class="dv">6</span> No such device or address</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>E2BIG <span class="dv">7</span> Argument list too <span class="dt">long</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>ENOEXEC <span class="dv">8</span> Exec format error</span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>EBADF <span class="dv">9</span> Bad file descriptor</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>ECHILD <span class="dv">10</span> No child processes</span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>EAGAIN <span class="dv">11</span> Resource temporarily unavailable</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>ENOMEM <span class="dv">12</span> Cannot allocate memory</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>EACCES <span class="dv">13</span> Permission denied</span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>EFAULT <span class="dv">14</span> Bad address</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>ENOTBLK <span class="dv">15</span> Block device required</span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>EBUSY <span class="dv">16</span> Device or resource busy</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>EEXIST <span class="dv">17</span> File exists</span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>EXDEV <span class="dv">18</span> Invalid cross<span class="op">-</span>device link</span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>ENODEV <span class="dv">19</span> No such device</span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>ENOTDIR <span class="dv">20</span> Not a directory</span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>EISDIR <span class="dv">21</span> Is a directory</span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>EINVAL <span class="dv">22</span> Invalid argument</span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>ENFILE <span class="dv">23</span> Too many open files in system</span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>EMFILE <span class="dv">24</span> Too many open files</span>
<span id="cb89-25"><a href="#cb89-25" aria-hidden="true" tabindex="-1"></a>ENOTTY <span class="dv">25</span> Inappropriate ioctl <span class="cf">for</span> device</span>
<span id="cb89-26"><a href="#cb89-26" aria-hidden="true" tabindex="-1"></a>ETXTBSY <span class="dv">26</span> Text file busy</span>
<span id="cb89-27"><a href="#cb89-27" aria-hidden="true" tabindex="-1"></a>EFBIG <span class="dv">27</span> File too large</span>
<span id="cb89-28"><a href="#cb89-28" aria-hidden="true" tabindex="-1"></a>ENOSPC <span class="dv">28</span> No space left on device</span>
<span id="cb89-29"><a href="#cb89-29" aria-hidden="true" tabindex="-1"></a>ESPIPE <span class="dv">29</span> Illegal seek</span>
<span id="cb89-30"><a href="#cb89-30" aria-hidden="true" tabindex="-1"></a>EROFS <span class="dv">30</span> Read<span class="op">-</span>only file system</span>
<span id="cb89-31"><a href="#cb89-31" aria-hidden="true" tabindex="-1"></a>EMLINK <span class="dv">31</span> Too many links</span>
<span id="cb89-32"><a href="#cb89-32" aria-hidden="true" tabindex="-1"></a>EPIPE <span class="dv">32</span> Broken pipe</span>
<span id="cb89-33"><a href="#cb89-33" aria-hidden="true" tabindex="-1"></a>EDOM <span class="dv">33</span> Numerical argument out of domain</span>
<span id="cb89-34"><a href="#cb89-34" aria-hidden="true" tabindex="-1"></a>ERANGE <span class="dv">34</span> Numerical result out of range</span>
<span id="cb89-35"><a href="#cb89-35" aria-hidden="true" tabindex="-1"></a>EDEADLK <span class="dv">35</span> Resource deadlock avoided</span>
<span id="cb89-36"><a href="#cb89-36" aria-hidden="true" tabindex="-1"></a>ENAMETOOLONG <span class="dv">36</span> File name too <span class="dt">long</span></span>
<span id="cb89-37"><a href="#cb89-37" aria-hidden="true" tabindex="-1"></a>ENOLCK <span class="dv">37</span> No locks available</span>
<span id="cb89-38"><a href="#cb89-38" aria-hidden="true" tabindex="-1"></a>ENOSYS <span class="dv">38</span> Function not implemented</span>
<span id="cb89-39"><a href="#cb89-39" aria-hidden="true" tabindex="-1"></a>ENOTEMPTY <span class="dv">39</span> Directory not empty</span>
<span id="cb89-40"><a href="#cb89-40" aria-hidden="true" tabindex="-1"></a>ELOOP <span class="dv">40</span> Too many levels of symbolic links</span>
<span id="cb89-41"><a href="#cb89-41" aria-hidden="true" tabindex="-1"></a>EWOULDBLOCK <span class="dv">11</span> Resource temporarily unavailable</span>
<span id="cb89-42"><a href="#cb89-42" aria-hidden="true" tabindex="-1"></a>ENOMSG <span class="dv">42</span> No message of desired type</span>
<span id="cb89-43"><a href="#cb89-43" aria-hidden="true" tabindex="-1"></a>EIDRM <span class="dv">43</span> Identifier removed</span>
<span id="cb89-44"><a href="#cb89-44" aria-hidden="true" tabindex="-1"></a>ECHRNG <span class="dv">44</span> Channel number out of range</span>
<span id="cb89-45"><a href="#cb89-45" aria-hidden="true" tabindex="-1"></a>EL2NSYNC <span class="dv">45</span> Level <span class="dv">2</span> not synchronized</span>
<span id="cb89-46"><a href="#cb89-46" aria-hidden="true" tabindex="-1"></a>EL3HLT <span class="dv">46</span> Level <span class="dv">3</span> halted</span>
<span id="cb89-47"><a href="#cb89-47" aria-hidden="true" tabindex="-1"></a>EL3RST <span class="dv">47</span> Level <span class="dv">3</span> reset</span>
<span id="cb89-48"><a href="#cb89-48" aria-hidden="true" tabindex="-1"></a>ELNRNG <span class="dv">48</span> Link number out of range</span>
<span id="cb89-49"><a href="#cb89-49" aria-hidden="true" tabindex="-1"></a>EUNATCH <span class="dv">49</span> Protocol driver not attached</span>
<span id="cb89-50"><a href="#cb89-50" aria-hidden="true" tabindex="-1"></a>ENOCSI <span class="dv">50</span> No CSI structure available</span>
<span id="cb89-51"><a href="#cb89-51" aria-hidden="true" tabindex="-1"></a>EL2HLT <span class="dv">51</span> Level <span class="dv">2</span> halted</span>
<span id="cb89-52"><a href="#cb89-52" aria-hidden="true" tabindex="-1"></a>EBADE <span class="dv">52</span> Invalid exchange</span>
<span id="cb89-53"><a href="#cb89-53" aria-hidden="true" tabindex="-1"></a>EBADR <span class="dv">53</span> Invalid request descriptor</span>
<span id="cb89-54"><a href="#cb89-54" aria-hidden="true" tabindex="-1"></a>EXFULL <span class="dv">54</span> Exchange full</span>
<span id="cb89-55"><a href="#cb89-55" aria-hidden="true" tabindex="-1"></a>ENOANO <span class="dv">55</span> No anode</span>
<span id="cb89-56"><a href="#cb89-56" aria-hidden="true" tabindex="-1"></a>EBADRQC <span class="dv">56</span> Invalid request code</span>
<span id="cb89-57"><a href="#cb89-57" aria-hidden="true" tabindex="-1"></a>EBADSLT <span class="dv">57</span> Invalid slot</span>
<span id="cb89-58"><a href="#cb89-58" aria-hidden="true" tabindex="-1"></a>EDEADLOCK <span class="dv">35</span> Resource deadlock avoided</span>
<span id="cb89-59"><a href="#cb89-59" aria-hidden="true" tabindex="-1"></a>EBFONT <span class="dv">59</span> Bad font file format</span>
<span id="cb89-60"><a href="#cb89-60" aria-hidden="true" tabindex="-1"></a>ENOSTR <span class="dv">60</span> Device not a stream</span>
<span id="cb89-61"><a href="#cb89-61" aria-hidden="true" tabindex="-1"></a>ENODATA <span class="dv">61</span> No data available</span>
<span id="cb89-62"><a href="#cb89-62" aria-hidden="true" tabindex="-1"></a>ETIME <span class="dv">62</span> Timer expired</span>
<span id="cb89-63"><a href="#cb89-63" aria-hidden="true" tabindex="-1"></a>ENOSR <span class="dv">63</span> Out of streams resources</span>
<span id="cb89-64"><a href="#cb89-64" aria-hidden="true" tabindex="-1"></a>ENONET <span class="dv">64</span> Machine is not on the network</span>
<span id="cb89-65"><a href="#cb89-65" aria-hidden="true" tabindex="-1"></a>ENOPKG <span class="dv">65</span> Package not installed</span>
<span id="cb89-66"><a href="#cb89-66" aria-hidden="true" tabindex="-1"></a>EREMOTE <span class="dv">66</span> Object is remote</span>
<span id="cb89-67"><a href="#cb89-67" aria-hidden="true" tabindex="-1"></a>ENOLINK <span class="dv">67</span> Link has been severed</span>
<span id="cb89-68"><a href="#cb89-68" aria-hidden="true" tabindex="-1"></a>EADV <span class="dv">68</span> Advertise error</span>
<span id="cb89-69"><a href="#cb89-69" aria-hidden="true" tabindex="-1"></a>ESRMNT <span class="dv">69</span> Srmount error</span>
<span id="cb89-70"><a href="#cb89-70" aria-hidden="true" tabindex="-1"></a>ECOMM <span class="dv">70</span> Communication error on send</span>
<span id="cb89-71"><a href="#cb89-71" aria-hidden="true" tabindex="-1"></a>EPROTO <span class="dv">71</span> Protocol error</span>
<span id="cb89-72"><a href="#cb89-72" aria-hidden="true" tabindex="-1"></a>EMULTIHOP <span class="dv">72</span> Multihop attempted</span>
<span id="cb89-73"><a href="#cb89-73" aria-hidden="true" tabindex="-1"></a>EDOTDOT <span class="dv">73</span> RFS specific error</span>
<span id="cb89-74"><a href="#cb89-74" aria-hidden="true" tabindex="-1"></a>EBADMSG <span class="dv">74</span> Bad message</span>
<span id="cb89-75"><a href="#cb89-75" aria-hidden="true" tabindex="-1"></a>EOVERFLOW <span class="dv">75</span> Value too large <span class="cf">for</span> defined data type</span>
<span id="cb89-76"><a href="#cb89-76" aria-hidden="true" tabindex="-1"></a>ENOTUNIQ <span class="dv">76</span> Name not unique on network</span>
<span id="cb89-77"><a href="#cb89-77" aria-hidden="true" tabindex="-1"></a>EBADFD <span class="dv">77</span> File descriptor in bad state</span>
<span id="cb89-78"><a href="#cb89-78" aria-hidden="true" tabindex="-1"></a>EREMCHG <span class="dv">78</span> Remote address changed</span>
<span id="cb89-79"><a href="#cb89-79" aria-hidden="true" tabindex="-1"></a>ELIBACC <span class="dv">79</span> Can not access a needed shared library</span>
<span id="cb89-80"><a href="#cb89-80" aria-hidden="true" tabindex="-1"></a>ELIBBAD <span class="dv">80</span> Accessing a corrupted shared library</span>
<span id="cb89-81"><a href="#cb89-81" aria-hidden="true" tabindex="-1"></a>ELIBSCN <span class="dv">81</span> <span class="op">.</span>lib section in a<span class="op">.</span>out corrupted</span>
<span id="cb89-82"><a href="#cb89-82" aria-hidden="true" tabindex="-1"></a>ELIBMAX <span class="dv">82</span> Attempting to link in too many shared libraries</span>
<span id="cb89-83"><a href="#cb89-83" aria-hidden="true" tabindex="-1"></a>ELIBEXEC <span class="dv">83</span> Cannot exec a shared library directly</span>
<span id="cb89-84"><a href="#cb89-84" aria-hidden="true" tabindex="-1"></a>EILSEQ <span class="dv">84</span> Invalid or incomplete multibyte or wide character</span>
<span id="cb89-85"><a href="#cb89-85" aria-hidden="true" tabindex="-1"></a>ERESTART <span class="dv">85</span> Interrupted system call should be restarted</span>
<span id="cb89-86"><a href="#cb89-86" aria-hidden="true" tabindex="-1"></a>ESTRPIPE <span class="dv">86</span> Streams pipe error</span>
<span id="cb89-87"><a href="#cb89-87" aria-hidden="true" tabindex="-1"></a>EUSERS <span class="dv">87</span> Too many users</span>
<span id="cb89-88"><a href="#cb89-88" aria-hidden="true" tabindex="-1"></a>ENOTSOCK <span class="dv">88</span> Socket operation on non<span class="op">-</span>socket</span>
<span id="cb89-89"><a href="#cb89-89" aria-hidden="true" tabindex="-1"></a>EDESTADDRREQ <span class="dv">89</span> Destination address required</span>
<span id="cb89-90"><a href="#cb89-90" aria-hidden="true" tabindex="-1"></a>EMSGSIZE <span class="dv">90</span> Message too <span class="dt">long</span></span>
<span id="cb89-91"><a href="#cb89-91" aria-hidden="true" tabindex="-1"></a>EPROTOTYPE <span class="dv">91</span> Protocol wrong type <span class="cf">for</span> socket</span>
<span id="cb89-92"><a href="#cb89-92" aria-hidden="true" tabindex="-1"></a>ENOPROTOOPT <span class="dv">92</span> Protocol not available</span>
<span id="cb89-93"><a href="#cb89-93" aria-hidden="true" tabindex="-1"></a>EPROTONOSUPPORT <span class="dv">93</span> Protocol not supported</span>
<span id="cb89-94"><a href="#cb89-94" aria-hidden="true" tabindex="-1"></a>ESOCKTNOSUPPORT <span class="dv">94</span> Socket type not supported</span>
<span id="cb89-95"><a href="#cb89-95" aria-hidden="true" tabindex="-1"></a>EOPNOTSUPP <span class="dv">95</span> Operation not supported</span>
<span id="cb89-96"><a href="#cb89-96" aria-hidden="true" tabindex="-1"></a>EPFNOSUPPORT <span class="dv">96</span> Protocol family not supported</span>
<span id="cb89-97"><a href="#cb89-97" aria-hidden="true" tabindex="-1"></a>EAFNOSUPPORT <span class="dv">97</span> Address family not supported by protocol</span>
<span id="cb89-98"><a href="#cb89-98" aria-hidden="true" tabindex="-1"></a>EADDRINUSE <span class="dv">98</span> Address already in use</span>
<span id="cb89-99"><a href="#cb89-99" aria-hidden="true" tabindex="-1"></a>EADDRNOTAVAIL <span class="dv">99</span> Cannot assign requested address</span>
<span id="cb89-100"><a href="#cb89-100" aria-hidden="true" tabindex="-1"></a>ENETDOWN <span class="dv">100</span> Network is down</span>
<span id="cb89-101"><a href="#cb89-101" aria-hidden="true" tabindex="-1"></a>ENETUNREACH <span class="dv">101</span> Network is unreachable</span>
<span id="cb89-102"><a href="#cb89-102" aria-hidden="true" tabindex="-1"></a>ENETRESET <span class="dv">102</span> Network dropped connection on reset</span>
<span id="cb89-103"><a href="#cb89-103" aria-hidden="true" tabindex="-1"></a>ECONNABORTED <span class="dv">103</span> Software caused connection abort</span>
<span id="cb89-104"><a href="#cb89-104" aria-hidden="true" tabindex="-1"></a>ECONNRESET <span class="dv">104</span> Connection reset by peer</span>
<span id="cb89-105"><a href="#cb89-105" aria-hidden="true" tabindex="-1"></a>ENOBUFS <span class="dv">105</span> No buffer space available</span>
<span id="cb89-106"><a href="#cb89-106" aria-hidden="true" tabindex="-1"></a>EISCONN <span class="dv">106</span> Transport endpoint is already connected</span>
<span id="cb89-107"><a href="#cb89-107" aria-hidden="true" tabindex="-1"></a>ENOTCONN <span class="dv">107</span> Transport endpoint is not connected</span>
<span id="cb89-108"><a href="#cb89-108" aria-hidden="true" tabindex="-1"></a>ESHUTDOWN <span class="dv">108</span> Cannot send after transport endpoint shutdown</span>
<span id="cb89-109"><a href="#cb89-109" aria-hidden="true" tabindex="-1"></a>ETOOMANYREFS <span class="dv">109</span> Too many references<span class="op">:</span> cannot splice</span>
<span id="cb89-110"><a href="#cb89-110" aria-hidden="true" tabindex="-1"></a>ETIMEDOUT <span class="dv">110</span> Connection timed out</span>
<span id="cb89-111"><a href="#cb89-111" aria-hidden="true" tabindex="-1"></a>ECONNREFUSED <span class="dv">111</span> Connection refused</span>
<span id="cb89-112"><a href="#cb89-112" aria-hidden="true" tabindex="-1"></a>EHOSTDOWN <span class="dv">112</span> Host is down</span>
<span id="cb89-113"><a href="#cb89-113" aria-hidden="true" tabindex="-1"></a>EHOSTUNREACH <span class="dv">113</span> No route to host</span>
<span id="cb89-114"><a href="#cb89-114" aria-hidden="true" tabindex="-1"></a>EALREADY <span class="dv">114</span> Operation already in progress</span>
<span id="cb89-115"><a href="#cb89-115" aria-hidden="true" tabindex="-1"></a>EINPROGRESS <span class="dv">115</span> Operation now in progress</span>
<span id="cb89-116"><a href="#cb89-116" aria-hidden="true" tabindex="-1"></a>ESTALE <span class="dv">116</span> Stale file handle</span>
<span id="cb89-117"><a href="#cb89-117" aria-hidden="true" tabindex="-1"></a>EUCLEAN <span class="dv">117</span> Structure needs cleaning</span>
<span id="cb89-118"><a href="#cb89-118" aria-hidden="true" tabindex="-1"></a>ENOTNAM <span class="dv">118</span> Not a XENIX named type file</span>
<span id="cb89-119"><a href="#cb89-119" aria-hidden="true" tabindex="-1"></a>ENAVAIL <span class="dv">119</span> No XENIX semaphores available</span>
<span id="cb89-120"><a href="#cb89-120" aria-hidden="true" tabindex="-1"></a>EISNAM <span class="dv">120</span> Is a named type file</span>
<span id="cb89-121"><a href="#cb89-121" aria-hidden="true" tabindex="-1"></a>EREMOTEIO <span class="dv">121</span> Remote I<span class="op">/</span>O error</span>
<span id="cb89-122"><a href="#cb89-122" aria-hidden="true" tabindex="-1"></a>EDQUOT <span class="dv">122</span> Disk quota exceeded</span>
<span id="cb89-123"><a href="#cb89-123" aria-hidden="true" tabindex="-1"></a>ENOMEDIUM <span class="dv">123</span> No medium found</span>
<span id="cb89-124"><a href="#cb89-124" aria-hidden="true" tabindex="-1"></a>EMEDIUMTYPE <span class="dv">124</span> Wrong medium type</span>
<span id="cb89-125"><a href="#cb89-125" aria-hidden="true" tabindex="-1"></a>ECANCELED <span class="dv">125</span> Operation canceled</span>
<span id="cb89-126"><a href="#cb89-126" aria-hidden="true" tabindex="-1"></a>ENOKEY <span class="dv">126</span> Required key not available</span>
<span id="cb89-127"><a href="#cb89-127" aria-hidden="true" tabindex="-1"></a>EKEYEXPIRED <span class="dv">127</span> Key has expired</span>
<span id="cb89-128"><a href="#cb89-128" aria-hidden="true" tabindex="-1"></a>EKEYREVOKED <span class="dv">128</span> Key has been revoked</span>
<span id="cb89-129"><a href="#cb89-129" aria-hidden="true" tabindex="-1"></a>EKEYREJECTED <span class="dv">129</span> Key was rejected by service</span>
<span id="cb89-130"><a href="#cb89-130" aria-hidden="true" tabindex="-1"></a>EOWNERDEAD <span class="dv">130</span> Owner died</span>
<span id="cb89-131"><a href="#cb89-131" aria-hidden="true" tabindex="-1"></a>ENOTRECOVERABLE <span class="dv">131</span> State not recoverable</span>
<span id="cb89-132"><a href="#cb89-132" aria-hidden="true" tabindex="-1"></a>ERFKILL <span class="dv">132</span> Operation not possible due to RF<span class="op">-</span>kill</span>
<span id="cb89-133"><a href="#cb89-133" aria-hidden="true" tabindex="-1"></a>EHWPOISON <span class="dv">133</span> Memory page has hardware error</span>
<span id="cb89-134"><a href="#cb89-134" aria-hidden="true" tabindex="-1"></a>ENOTSUP <span class="dv">95</span> Operation not supported</span></code></pre></div>
            <h3 data-number="4.5.3"
            id="additional-helper-functions"><span
            class="header-section-number">4.5.3</span> Additional Helper
            Functions</h3>
            <p>The C standard library includes two additional helper
            functions for dealing with errors:</p>
            <table>
            <colgroup>
            <col style="width: 30%" />
            <col style="width: 33%" />
            <col style="width: 36%" />
            </colgroup>
            <thead>
            <tr class="header">
            <th>function</th>
            <th>operation</th>
            <th>defined in</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td><code>perror()</code></td>
            <td><strong>print</strong> an error to the console,
            corresponding to <sc>errno</sc></td>
            <td><code>error.h</code></td>
            </tr>
            <tr class="even">
            <td><code>strerror()</code></td>
            <td><strong>return</strong> a <strong>string</strong>
            corresponding to <sc>errno</sc></td>
            <td><code>string.h</code></td>
            </tr>
            <tr class="odd">
            <td></td>
            <td></td>
            <td></td>
            </tr>
            </tbody>
            </table>
            <p>Check out their <code>man</code> pages for more
            information.</p>
            <p>Consider the following example for understanding the use
            of <code>perror()</code> and <code>strerror()</code>:</p>
            <div class="sourceCode" id="cb90"><pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* CSC 2410 Code Sample </span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * intro to error handling in C</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="co"> * Fall 2023</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="co"> * (c) Sibin Mohan</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;error.h&gt;</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// try to create an array of LONG_MAX size, </span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// i.e. 9223372036854775807 bytes!</span></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> massive_array <span class="op">=</span> <span class="op">(</span><span class="dt">char</span><span class="op">*)</span> malloc<span class="op">(</span>LONG_MAX<span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if array was created</span></span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(</span> <span class="op">!</span>massive_array <span class="op">)</span></span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb90-23"><a href="#cb90-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Uh oh! Looks like Array creation failed. </span></span>
<span id="cb90-24"><a href="#cb90-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// print the errno</span></span>
<span id="cb90-25"><a href="#cb90-25" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span> <span class="st">&quot;errno = </span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> errno <span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-26"><a href="#cb90-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-27"><a href="#cb90-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Send custom error message and also print system message</span></span>
<span id="cb90-28"><a href="#cb90-28" aria-hidden="true" tabindex="-1"></a>        perror<span class="op">(</span> <span class="st">&quot;My Massive Array creation failed!&quot;</span> <span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-29"><a href="#cb90-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb90-30"><a href="#cb90-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-31"><a href="#cb90-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can set errno explicitly</span></span>
<span id="cb90-32"><a href="#cb90-32" aria-hidden="true" tabindex="-1"></a>    errno <span class="op">=</span> <span class="dv">100</span> <span class="op">;</span></span>
<span id="cb90-33"><a href="#cb90-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> error_string <span class="op">=</span> strerror<span class="op">(</span>errno<span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-34"><a href="#cb90-34" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">errno = </span><span class="sc">%d\t</span><span class="st"> (standard) String = </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> errno<span class="op">,</span> error_string <span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-35"><a href="#cb90-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-36"><a href="#cb90-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// can give it any input, really</span></span>
<span id="cb90-37"><a href="#cb90-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span> my_errno <span class="op">=</span> <span class="dv">9999</span> <span class="op">;</span></span>
<span id="cb90-38"><a href="#cb90-38" aria-hidden="true" tabindex="-1"></a>    error_string <span class="op">=</span> strerror<span class="op">(</span> my_errno <span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-39"><a href="#cb90-39" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">my_errno = </span><span class="sc">%d\t</span><span class="st"> (custom) String = </span><span class="sc">%s\n</span><span class="st">&quot;</span><span class="op">,</span> my_errno<span class="op">,</span> error_string <span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-40"><a href="#cb90-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-41"><a href="#cb90-41" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">)</span> <span class="op">;</span></span>
<span id="cb90-42"><a href="#cb90-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span> <span class="op">;</span></span>
<span id="cb90-43"><a href="#cb90-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
            <p><strong>Note:</strong> look up <a
            href="https://www.tutorialspoint.com/c_standard_library/limits_h.htm"><code>&lt;limits.h&gt;</code></a>
            that defines some useful constants such as
            <code>INT_MAX</code>, <code>INT_MIN</code>,
            <code>LONG_MAX</code>, <em>etc.</em></p>
            <p><strong>Note:</strong> when you return from a program
            with a non-zero value, it designates that your
            <em>program</em> had an error. This is why we see the
            <code>make</code> error when it runs your program.</p>
            <h3 data-number="4.5.4"
            id="understand-return-values-of-unix-library-functions"><span
            class="header-section-number">4.5.4</span> Understand Return
            Values of UNIX library functions:</h3>
            <p>Look at the function return values to understand the type
            (and identify if it is returning an <code>int</code> or a
            pointer).</p>
            <pre><code>SYNOPSIS
       #include &lt;stdlib.h&gt;

       void *malloc(size_t size);
       ...</code></pre>
            <ul>
            <li>Read through the description of the function(s).</li>
            <li>Read through the <code>RETURN VALUE</code> and
            <code>ERRORS</code> sections of the man page.</li>
            </ul>
            <pre><code>RETURN VALUE
       The malloc() and calloc() functions return a pointer to the allocated memory, which is  suitably  aligned  for
       any  built-in type.  On error, these functions return NULL.  NULL may also be returned by a successful call to
       malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero.
...
ERRORS
       calloc(), malloc(), realloc(), and reallocarray() can fail with the following error:

       ENOMEM Out  of  memory.
       ...
</code></pre>
            <p>This explains why we got the error we did.</p>
            <h3 data-number="4.5.5"
            id="in-class-exercise-printing-all-error-codesstrings-in-sequence"><span
            class="header-section-number">4.5.5</span> In-class Exercise
            | Printing <strong>all</strong> error codes/strings in
            sequence</h3>
            <p>Write a <em>function</em> named,
            <code>print_error_codes()</code>, to print <em>all</em> the
            error codes and their corresponding strings <em>in
            sequence</em>, in the following format:</p>
            <pre><code>Error No     String
-------------------
1            Operation not permitted
2            No such file or directory
...</code></pre>
            </ol>
            </aside>
            </div>
    </div>
  </div>

</body>
</html>